<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<link href="common/css/sf.css" rel="stylesheet" type="text/css"/>
<title>Preface</title>
<link href="common/jquery-ui/jquery-ui.css" rel="stylesheet">
<link href="common/css/logical_foundations.css" rel="stylesheet" type="text/css"/>
<script src="common/jquery-ui/external/jquery/jquery.js"></script>
<script src="common/jquery-ui/jquery-ui.js"></script>
</head>

<body>

<div id="page">

<div id="header">
<a href="https://www.cis.upenn.edu/~bcpierce/sf/current/index.html"><img src="common/media/image/sf_logo_sm.png"></a>
<ul id="menu">
<li class='section_name'>Logical Foundations</li>
<a href="toc.html"><li>Table of Contents</li></a>
<a href="coqindex.html"><li>Index</li></a>
<a href="deps.html"><li>Roadmap</li></a>
</ul>
</div>

<div id="main">

<h1 class="libtitle">Preface</h1>


<div class="doc">
<a name="lab1"></a><h1 class="section">前言</h1>

</div>
<div class="code code-space">

<br/>
</div>

<div class="doc">
<a name="lab2"></a><h1 class="section">简介</h1>

<div class="paragraph"> </div>

 This electronic book is a course on <i>Software Foundations</i>, the
    mathematical underpinnings of reliable software.  Topics include
    basic concepts of logic, computer-assisted theorem proving, the
    Coq proof assistant, functional programming, operational
    semantics, Hoare logic, and static type systems.  The exposition
    is intended for a broad range of readers, from advanced
    undergraduates to PhD students and researchers.  No specific
    background in logic or programming languages is assumed, though a
    degree of mathematical maturity will be helpful.

<div class="paragraph"> </div>

    The principal novelty of the course is that it is one hundred
    percent formalized and machine-checked: the entire text is
    literally a script for Coq.  It is intended to be read
    alongside (or inside) an interactive session with Coq.  All the
    details in the text are fully formalized in Coq, and most of the
    exercises are designed to be worked using Coq.

<div class="paragraph"> </div>

    The files are organized into a sequence of core chapters, covering
    about one semester's worth of material and organized into a
    coherent linear narrative, plus a number of "offshoot" chapters
    covering additional topics.  All the core chapters are suitable
    for both upper-level undergraduate and graduate students. 
</div>

<div class="doc">
<a name="lab3"></a><h1 class="section">导论</h1>

<div class="paragraph"> </div>

 构建可靠软件是困难的。现代系统的规模和复杂度，参与项目的人员数量，
    以及它们所面临的包罗万象的需求，都使得构建正确软件这件事情格外困难
 即便这里的"正确"仅仅指部分的，远未及百分之百的正确。而与此同时，
    信息化却正在日益深入地融入到社会生活的方方面面，这又极大地增加了Bug
    和安全漏洞可能造成的损失。

<div class="paragraph"> </div>

    为了应对这些挑战，计算机科学家和软件工程师开发了一系列提高软件可靠性
    的技术，范围包括从对软件项目团队的管理建议（比如极限编程
    （Extreme Programming）），到软件库的设计哲学（比如模型-视图-控制器
    （Model-View-Controller），发布-订阅（Publish-Subscribe））
    以及从编程语言（比如面向对象编程（Object Oriented Programming），
    面向剖面编程（Aspect Oriented Programming），函数式编程
    （Functional Programming））到 指定和论证软件属性的数学技术及用于辅助
    验证这些属性的工具。本课程所讨论的正是最后这一类技术。

<div class="paragraph"> </div>

    本书将以下五个概念穿插在一起:

<div class="paragraph"> </div>

    (1) 来自 <i>'逻辑学'</i> 的基本工具，用于构建和检验关于程序的精确声明;

<div class="paragraph"> </div>

    (2) 关于 <i>'证明助理'</i> 的使用，以构造严谨的逻辑论证;

<div class="paragraph"> </div>

    (3) <i>'函数式编程'_，既作为编程的一种方法，简化了对程序的论证，
        也作为编程和逻辑之间的桥梁;

<div class="paragraph"> </div>

    (4) 用于 <i>'特定程序属性论证'</i> 的形式化技术 (例如排序函数或编译器
        服从某些形式化规范);

<div class="paragraph"> </div>

    (5) 使用 <i>'类型系统'</i> 为给定的编程语言中的 <i>'所有'</i> 程序建立良好的
        行为保证（例如，类型正确Java程序不能在运行时被破坏）。

<div class="paragraph"> </div>

    这五个主题中的任一个都足够丰富以至于其本身就能轻易填满一整个课程，
    因此把它们塞在一个课程中自然意味着很多内容会被遗留在外。
    尽管如此，我们仍希望读者会发现这五个主题相得益彰，它们会为读者
    打下坚实的基础，使读者可以轻松地深入任一主题。扩展阅读的建议可在
    <a href="Postscript.html"><span class="inlineref">Postscript</span></a> 一章中找到；所有被引述著作的书目信息可以在
    <a href="Bib.html"><span class="inlineref">Bib</span></a> 一章中找到。
<div class="paragraph"> </div>

<a name="lab4"></a><h2 class="section">逻辑学</h2>

<div class="paragraph"> </div>

 逻辑学的研究领域为证明——即对特定命题的真伪性进行不容置疑的论证。
    关于逻辑学在计算机科学中作用的资料汗牛充栋。
    Manna 以及 Waldinger 称之为“计算机科学的微积分”，而 Halpern 的论文
    <i>On the Unusual Effectiveness of Logic in Computer Science</i> 则列出了
    逻辑学为计算机科学提供的洞察力和至关重要的工具。的确，他们发现
    “事实上，逻辑学在计算机科学中远比在数学中更加有效。
    这很值得关注，特别是由于过去一百年来，逻辑学发展的动力大都来自于数学。”

<div class="paragraph"> </div>

    特别来说，归纳证明的基本概念在计算机科学中无处不在。
    你以前肯定见过它们，比如说在离散数学或算法分析中。不过在本课程中，
    我们会在你未曾涉及的深度下对其进行检测。
<div class="paragraph"> </div>

<a name="lab5"></a><h2 class="section">证明助理</h2>

<div class="paragraph"> </div>

 逻辑学与计算机科学之间的思想交流并不是单方面的：
    计算机科学也对逻辑学做出了重要的贡献，
    其中之一就是发展了可帮助构造命题/证明的软件工具。
    这些工具分为两类：

<div class="paragraph"> </div>

<ul class="doclist">
<li> <i>'自动化定理证明器'</i> 提供了一键式操作：它们接受一个命题，
         然后返回 <i>'真'</i> 或 <i>'假'</i> (或有时为 <i>'未知：超时'</i> )。
         尽管它们的能力仅限于特定种类的推理中，但在近几年却大幅成熟并应用于多种场合，
         自动化定理证明器的例子包括 SAT 求解器，SMT 求解器以及模型检查器（Model Checker）。

</li>
<li> <i>'证明助理'</i>  是一种混合式工具，它能将构建证明中比较常规的部分自动化，
         而更困难的部分则依赖于人类解决。常用的证明助理包括
         Isabelle、Agda、Twelf、ACL2、PVS 以及 Coq，还有很多其它的。

</li>
</ul>
    本课程围绕 Coq 展开。它是一个自 1983 年以来主要在法国开发的证明助理，
    近年来吸引了大量来自研究机构和业界的社区用户。
    Coq 为机器验证的形式化论证的交互式开发提供了丰富的环境。Coq 系统的内核是一个简单的证明验证器，
    它保证只会进行正确的推论步骤。在此内核之上，Coq 环境提供了高级的证明开发设施，
    包括一个包含各种定义和引理的庞大的库，用于半自动化构造证明的强大策略，
    以及一个专门为特殊情况定义新的自动证明策略的专用编程语言。
    Coq 已成为各种跨计算机科学和数学研究的关键推动者：

<div class="paragraph"> </div>

<ul class="doclist">
<li> 作为一个 <i>'编程语言的建模平台'</i> ，
      Coq 成为了研究员对复杂语言定义进行描述和论证的一个标准工具。
      例如，它被用来检查 JavaCard 平台的安全性，得到了最高等级的通用准则验证，
      它还被用在 x<sub>86</sub> 和 LLVM 指令集以及 C 之类的编程语言的形式化规范中。

</li>
<li> 作为一个 <i>'形式化验证软件的开发环境'</i> ，Coq 被用来构建：
      CompCert，一个完全验证过的 C 优化编译器；
      CertiKos，一个完全验证过的，用于证明浮点数相关精妙算法的正确性；
      Coq 也是 CertiCrypt，一个用于论证密码学算法安全性的环境的基础。
      它也被用来构建开源 RISC-V 处理器的已验证实现。

</li>
<li> 作为一个 <i>'带依赖类型的函数式编程的现实环境'</i> ，Coq 激发了大量的创新。
      例如 Ynot 系统嵌入了「关系式霍尔推理」（一个 <i>'霍尔逻辑'</i> 的扩展，我们会在后面看到它）。

</li>
<li> 作为一个 <i>'高阶逻辑的证明助理'</i> ，Coq 被用于证实数学中一些重要的结果。
      例如 Coq 可在证明中包含复杂计算的能力，使其开发出第一个形式化验证的四色定理证明。
      此前数学家们对该证明颇有争议，因为其中一部分用程序对大量组态进行了检查。
      在 Coq 的形式化中，所有东西都被检查了，自然包括计算方面的正确性。
      近年来，Feit-Thompson 定理在更大的努力下用 Coq 形式化了，
      这是对有限单群进行分类的第一大步。

</li>
</ul>
   顺便一提，如果你对 Coq 这个名字感到好奇，INRIA (法国国家研究实验室，Coq
   主要在这里开发）上的 Coq 官方网站给出了解释：
   「一些法国计算机科学家有用动物命名软件的传统：像 Caml、Elan、Foc、Phox
   都心照不宣地遵循这种默契。在法国，「Coq」是雄鸡，发音也像
   Calculus of Constructions 的首字母缩写（CoC），后者是 Coq 的基础。」
   高卢雄鸡是法国的象征。C-o-q 还是 Thierry Coquand 名字的前三个字母，
   他是 Coq 的早期开发者之一。 
<div class="paragraph"> </div>

<a name="lab6"></a><h2 class="section">函数式编程</h2>

<div class="paragraph"> </div>

 <i>'函数式编程'</i> 既代表几乎可以在任何编程语言中使用的一系列惯用法，也代表着一族
    以这些习惯用法为侧重点设计的编程语言，包括 Haskell、OCaml、Standard ML、F#、
    Scala、Scheme、Racket、Common Lisp、Erlang 还有 Coq。
    函数式编程已经有数十年历史了&mdash;实际上，它甚至可以追溯到 1930
    年代 Church 发明的 λ-演算，那时候还没有计算机呢！自 90 年代初以来，
    函数式编程激起了业内软件工程师和语言设计者浓厚的兴趣，它还在
    Jane St. Capital、Microsoft、Facebook 和 Ericsson
    等公司的高价值系统中发挥着关键的作用。
    函数式编程最根本的原则是，计算应当尽可能地 <i>'纯粹'</i> ，也就是说，
    执行代码的唯一效果应当是只产生一个结果：计算应当没有 <i>'副作用'</i> ，
    即与输入/输出、可变量的赋值、指针重定向等等脱离。
    例如，一个命令式的排序函数会接受一个数字列表，通过重组指针使列表得以排序；
    而一个纯粹的排序函数则会取一个列表，返回一个含有同样数字，但是已排序的新列表。
    这种编程风格最明显的好处之一，就是它能让程序变得更容易理解和论证。
    如果对某个数据结构的所有操作都会返回新的数据结构，而旧有的结构没有变动，
    那么我们便无需担心它的共享方式，因为程序中一部分的改变并不会破坏另一部分的属性。
    在并发程序中，线程间共享的每一个可变状态都是致命 Bug 的潜在来源，
    因此这方面的考虑尤为关键。事实上，业界最近对函数式编程的兴趣大部分来源于此，
    即它在并发中表现出的简单行为。
    人们对函数式编程感到兴奋的另一原因与前文所述的原因相关：
    函数式程序通常比命令式程序更容易并行化。
    如果一个计算除了产生结果之外没有其它的作用，那么它在 <i>'何时'</i> 执行便不再重要。
    同样，如果一个数据结构不会被破坏性地修改，那么它可以跨核心或网络地被随意复制。
    其实，「映射-归纳」（Map-Reduce）的惯用法就是函数式编程的经典例子，
    它在大规模分布式查询处理器（如 Hadoop）中处于核心地位，并被 Google
    用来索引整个互联网。
    对于本课程而言，函数式编程还有另一个重要的吸引力：
    它在逻辑与计算机科学之间架起了一座桥梁。事实上，Coq
    本身即可视作一个小巧却有着极强表达能力的函数式编程语言，
    以及一组用于陈述和证明逻辑断言的工具的结合体。进而言之，
    当我们更加深入地审视它时，会发现 Coq 的这两方面其实基于几乎相同的底层机制
 <i>'命题即类型，程序即证明'</i> ，可谓殊途同归。 
<div class="paragraph"> </div>

<a name="lab7"></a><h2 class="section">程序验证</h2>

<div class="paragraph"> </div>

 本书的前三分之一用于发展逻辑学以及函数式编程的概念框架，提升用
    Coq 对非平凡构造进行建模和论证的熟练度。此后，我们会逐渐将重点转移到
    对构建可靠软件（和硬件）的事业而言至关重要的两个主题上：
    用于证明特定 <i>'程序'</i> 具体属性的技巧，以及用于证明整个编程 <i>'语言'</i> 共通属性的技术。
    对于这两个主题来说，我们首先要找出一种用将程序表示为数学对象的方法，
    以此来对二者进行精确的描述，以及用函数或关系表示它们的行为。
    对此而言，我们的工具是抽象语法（Abstract Syntax）和操作语义（Operational
    Semantics），一种通过编写抽象解释器来指定程序行为的方法。
    首先，我们尽量用「大跨步」的方式来产生更加简单可读的操作语义；
    之后，我们会转换到更加详细的「小碎步」风格，这样能有效地区分不同种类的「非最终」
    程序的行为，这种方式适用于更加广泛的语言特性，包括并发。
    我们要仔细考虑的第一个编程语言是 <i>Imp</i> ，一个小巧的玩具编程语言，
    它包含了传统命令式编程的核心特性：变量、赋值、条件和循环。
    我们会学习两种不同的方法来对 Imp 程序的属性进行论证。
    首先，若两个 Imp 程序在任何初始内存状态下启动都有相同的行为，
    那么我们便认为二者是 <i>'等价的'</i> 。这种等价的概念便成为了判定元程序
    （操控其它程序的程序，比如编译器和优化器）正确性的标准。
    我们会为 Imp 构建一个简单的优化器并证明其正确性。
    之后，我们会发展出一套方法论，用于证明特定 Imp 程序的行为是否满足其形式化规范。
    我们会介绍 <i>'霍尔三元组'</i> （Hoare triples）的概念：带有前置和后置条件的 Imp
    程序描述了在它启动时，内存中的什么应该为真；在它终止后，它保证内存中的什么为真。
    也会介绍 <i>'霍尔逻辑'</i> （Hoare Logic）的推理原则：一种内建了循环不变式（loop-invariant）
    等概念的「领域专用逻辑」，以便对命令式程序进行组合推理。
    本课程的这一部分意在让读者尝试各种现实中软件和硬件的证明工作，
    以此来获得所需要的关键思想和数学工具。
<div class="paragraph"> </div>

<a name="lab8"></a><h2 class="section">类型系统</h2>

<div class="paragraph"> </div>

 我们的最后一个主题为 <i>'类型系统'</i> ，它覆盖了课程最后的三分之一。
    它是一组强大的工具，用于构建给定语言中 <i>'所有'</i> 程序的属性。
    类型系统是最久经考验、最流行也是最成功的一类形式化验证技术的例子，
    它被称作 <i>'轻量级形式化方法'</i> （lightweight formal methods）。
    它们是低调而强大的论证技术，以至于自动检查器可以内建在在编译器、
    连接器或程序分析器中，而程序员无需熟悉底层理论便可应用。
    其它轻量级形式化方法的例子包括硬件和软件的模型检查器、契约检查器，
    以及运行时属性监视技术，它用来检测一个系统中某些组件的行为是否遵循规范）。
    该主题使得本课程终归圆满：我们在这一部分研究的语言，即 <i>'简单类型化 λ-演算'</i> ，
    它本质上就是 Coq 核心自身的一个简化模型！

</div>

<div class="doc">
<a name="lab9"></a><h2 class="section">扩展阅读</h2>

<div class="paragraph"> </div>

 此书旨在自成一体，不过想要对特定主题进行深入研究的读者，可以在 <a href="Postscript.html"><span class="inlineref">Postscript</span></a>
    一章中找到建议的扩展阅读。 
</div>

<div class="doc">
<a name="lab10"></a><h1 class="section">实用指南</h1>

<div class="paragraph"> </div>

<a name="lab11"></a><h2 class="section">章节依赖</h2>

<div class="paragraph"> </div>

 章节之间的依赖关系以及一些建议的路径图可以在文件
    <a href="deps.html"><span class="inlineref"><span class="inlinecode"><span class="id" type="var">deps.html</span></span></span></a> 中找到。 
<div class="paragraph"> </div>

<a name="lab12"></a><h2 class="section">系统需求</h2>

<div class="paragraph"> </div>

 Coq 可以在 Windows、Linux 和 OS X 上运行。你需要：

<div class="paragraph"> </div>

<ul class="doclist">
<li> 一个最近的 Coq 安装，可以从 Coq 主页获得。所有内容都能在 8.4（或 8.5）上运行。

</li>
<li> 一个能跟 Coq 交互的 IDE。目前为止有两个选项：
<ul class="doclist">
<li> Proof General 是一个基于 Emacs 的 IDE，Emacs 用户应该更喜欢这个。
             它需要另外安装（Google 搜索「Proof General」）。
             爱作死的 Emacs 党也可以试试 <span class="inlinecode"><span class="id" type="var">company</span>-<span class="id" type="var">coq</span></span> 和 <span class="inlinecode"><span class="id" type="var">control</span>-<span class="id" type="var">lock</span></span>
             之类的扩展。

</li>
<li> CoqIDE 是一个更简单的独立 IDE。它随 Coq 一起发布，所以若你已经安装了
             Coq，它应该「刚好能用」。它也可以通过对应的依赖从头编译安装，
             不过在某些平台上还需要额外安装 GUI 库之类的东西。 
</li>
</ul>

</li>
</ul>

<div class="paragraph"> </div>

<a name="lab13"></a><h2 class="section">练习</h2>

<div class="paragraph"> </div>

 每一章都包含大量的习题。每一个习题都有一个“星级”标记，其意义是：

<div class="paragraph"> </div>

<ul class="doclist">
<li> 一星：很简单的，强调课程重点的习题。对于大部分读者，一两分钟应该足够了。
         养成看到一个就做一个的习惯。

<div class="paragraph"> </div>


</li>
<li> 二星：直截了当的习题（5 或 10分钟）。

<div class="paragraph"> </div>


</li>
<li> 三星：需要一点思考的习题（10 分钟到半小时）。

<div class="paragraph"> </div>


</li>
<li> 四或五星：更困难的习题（半小时以上）。

</li>
</ul>

<div class="paragraph"> </div>

    此外，有些习题被标注为“高阶”，有些习题被标注为“可选”。
    只做非高阶和非可选的习题已经能达到对核心概念的不错的覆盖率。
    可选习题会提供一点对关键概念的额外练习，以及一些可能会引起读者兴趣的附加主题。
    高阶练习留给想要更多挑战（以及对概念更深的理解）的读者。

<div class="paragraph"> </div>

    <span class="loud"> <i>'请勿将习题解答发布在公共位置'</i> . </span>
    Software Foundation
    已被广泛地用作自学教程以及大学课程。如果习题答案很容易获得，
    那么这本书的效用将大打折扣，对于会为作业打评分的大学课程来说尤其如此。
    作者特别请求读者，切勿将习题答案放在任何能够被搜索引擎找到的地方。

<div class="paragraph"> </div>

<a name="lab14"></a><h2 class="section">下载 Coq 文件</h2>

<div class="paragraph"> </div>

 一个包含本书「发布版」的所有源代码的 tar 包
    （包含一组 Coq 脚本和 HTML 文件）可在此获得：
<pre>
        <a href="http://www.cis.upenn.edu/~bcpierce/sf"><span class="inlineref">http://www.cis.upenn.edu/~bcpierce/sf</span></a>
</pre>
    本书的中文版可在此获得：
<pre>
        <a href="https://github.com/MarisaKirisame/SFCT"><span class="inlineref">https://github.com/MarisaKirisame/SFCT</span></a>
</pre>
    （如果你是在一门课程中使用本书的，那么你的教授可能让你访问本地的修改版，
    此时你应当使用它们而非发布版。）
</div>

<div class="doc">
<a name="lab15"></a><h1 class="section">对授课员的标准</h1>

<div class="paragraph"> </div>

 如果你有意用这些课件授课，那肯定会发现希望改进或增加的东西。我们欢迎你的贡献！
    为保证法律上的简单性和单一责任制，任何情况下都不应出现许可条款的的调整，
    授权的转移等等，我们要求所有贡献者（即，任何可访问开发者仓库的人）根据
    「作者记录」为他们的贡献赋予版权信息如下：

<div class="paragraph"> </div>

<ul class="doclist">
<li> I hereby assign copyright in my past and future contributions
        to the Software Foundations project to the Author of Record of
        each volume or component, to be licensed under the same terms
        as the rest of Software Foundations.  I understand that, at
        present, the Authors of Record are as follows: For Volumes 1
        and 2, known until 2016 as "Software Foundations" and from
        2016 as (respectively) "Logical Foundations" and "Programming
        Foundations," the Author of Record is Benjamin Pierce.  For
        Volume 3, "Verified Functional Algorithms", the Author of
        Record is Andrew W. Appel. For components outside of
        designated Volumes (e.g., typesetting and grading tools and
        other software infrastructure), the Author of Record is
        Benjamin Pierce.

</li>
</ul>
    请您向 Benjamin Pierce 发一封电子邮件，描述一下你自己，
    以及你打算如何使用这些课件，内容包括
       (1) 以上版权转让协议，以及
       (2) 执行 "htpasswd -s -n NAME" 后产生的结果，
    其中 NAME 是你喜欢的用户名。
    我们为你设置 subversion 仓库和开发者邮件列表的访问权限。
    在仓库中你会找到一个包含更多指引的 <span class="inlinecode"><span class="id" type="var">INSTRUCTORS</span></span> 文件。
</div>

<div class="doc">
<a name="lab16"></a><h1 class="section">翻译版</h1>

<div class="paragraph"> </div>

 感谢翻译志愿者团队的努力，<i>'Software Foundations'</i>
    有了可以阅读的日文版
    <a href="http://proofcafe.org/sf"><span class="inlinecode"><span class="id" type="var">http</span>://<span class="id" type="var">proofcafe.org</span>/<span class="id" type="var">sf</span></span></a>。
    中文版还在填坑= =||

<div class="paragraph"> </div>

  
</div>
</div>

<div id="footer">
<hr/><a href="coqindex.html">Index</a></div>

</div>

</body>
</html>