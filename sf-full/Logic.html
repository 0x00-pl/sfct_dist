<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<link href="common/css/sf.css" rel="stylesheet" type="text/css"/>
<title>Logic: Coq中的逻辑系统</title>
<link href="common/jquery-ui/jquery-ui.css" rel="stylesheet">
<link href="common/css/logical_foundations.css" rel="stylesheet" type="text/css"/>
<script src="common/jquery-ui/external/jquery/jquery.js"></script>
<script src="common/jquery-ui/jquery-ui.js"></script>
</head>

<body>

<div id="page">

<div id="header">
<a href="https://www.cis.upenn.edu/~bcpierce/sf/current/index.html"><img src="common/media/image/sf_logo_sm.png"></a>
<ul id="menu">
<li class='section_name'>Logical Foundations</li>
<a href="toc.html"><li>Table of Contents</li></a>
<a href="coqindex.html"><li>Index</li></a>
<a href="deps.html"><li>Roadmap</li></a>
</ul>
</div>

<div id="main">

<h1 class="libtitle">Logic<span class="subtitle">Coq中的逻辑系统</span></h1>


<div class="code code-tight">

<br/>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Export</span> <span class="id" type="var">Tactics</span>.<br/>
</div>

<div class="doc">
    在之前的章节中我们已经看到了很多有关事实性的声明（命题）和表达证实这些
    声明的正确性的证据（即证明）的方法的许多例子。比如说，至今为止我们已经
    做了许多<span class="inlinecode"><span class="id" type="var">e<sub>1</sub></span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">e<sub>2</sub></span></span>这样的 <i>'相等性命题'</i> ，形如<span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode"><span style="font-family: arial;">&rarr;</span></span> <span class="inlinecode"><span class="id" type="var">Q</span></span>这样的主体为蕴含式
    的命题，以及形如<span class="inlinecode"><span style="font-family: arial;">&forall;</span></span> <span class="inlinecode"><span class="id" type="var">x</span>,</span> <span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode"><span class="id" type="var">x</span></span>的量化命题的证明。
    在接触更多相关的细节之前，让我们先探讨一下在Coq中数学表达式的地位。回忆
    一下，Coq是一门 <i>'有类型的'</i> 语言；在Coq的世界中，一切有意义的表达式都有其
    类型。这类逻辑性的断言也是如此。所有我们试着去证明的命题在Coq中都有着<span class="inlinecode"><span class="id" type="keyword">Prop</span></span>
    这一 <i>'专门为命题设立的'</i> 类型。我们可以用Check去查看这类命题的类型：  
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Check</span> 3 = 3.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;Prop&nbsp;*)</span><br/>
<span class="id" type="keyword">Check</span> <span style="font-family: arial;">&forall;</span><span class="id" type="var">n</span> <span class="id" type="var">m</span> : <span class="id" type="var">nat</span>, <span class="id" type="var">n</span> + <span class="id" type="var">m</span> = <span class="id" type="var">m</span> + <span class="id" type="var">n</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;Prop&nbsp;*)</span><br/>
</div>

<div class="doc">
注意： <i>'所有语法上合法的命题的类型都为<span class="inlinecode"><span class="id" type="keyword">Prop</span></span>'</i> 。它们的类型与它们
    是否为真命题无关： <i>'本身成为'</i> 一个命题与 <i>'能得到这个命题的证明'</i> 
    是不同的两回事。 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Check</span> <span style="font-family: arial;">&forall;</span><span class="id" type="var">n</span> : <span class="id" type="var">nat</span>, <span class="id" type="var">n</span> = 2.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;Prop&nbsp;*)</span><br/>
<span class="id" type="keyword">Check</span> 3 = 4.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;Prop&nbsp;*)</span><br/>
</div>

<div class="doc">
    除了类型之外，命题也是所谓的 <i>'一等对象'</i> ，即在Coq的世界中，我们可以像对
    其他值进行操作一样对命题进行操作。到现在为止，我们已经知道命题可以在
    <span class="inlinecode"><span class="id" type="keyword">Theorem</span></span>（还有<span class="inlinecode"><span class="id" type="keyword">Lemma</span></span>和<span class="inlinecode"><span class="id" type="keyword">Example</span></span>）的定义中出现： 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">plus_2_2_is_4</span> :<br/>
&nbsp;&nbsp;2 + 2 = 4.<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
    但是它们同时也可以用于其他地方。比如说，就像我们用<span class="inlinecode"><span class="id" type="keyword">Definition</span></span>给某些
    函数或者其他类型的值取一个名字一样，我们可以用同样的方法为某些命题取
    一个名字： 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">plus_fact</span> : <span class="id" type="keyword">Prop</span> := 2 + 2 = 4.<br/>
<span class="id" type="keyword">Check</span> <span class="id" type="var">plus_fact</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;plus_fact&nbsp;:&nbsp;Prop&nbsp;*)</span><br/>
</div>

<div class="doc">
    在这之后我们可以在任何需要填入一个命题的地方使用这个名字，例如在一个
    Theorem声明中： 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">plus_fact_is_true</span> :<br/>
&nbsp;&nbsp;<span class="id" type="var">plus_fact</span>.<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
我们也可以写出所谓 <i>'参数化'</i> 的命题；它们实际上是一类函数：它们取某些
    类型的值作为参数，并最终得到一个命题。 
<div class="paragraph"> </div>


<div class="paragraph"> </div>

    例如下面的这个函数；它取一个数字，并返回一个断言了这个数字等于3的命题。 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">is_three</span> (<span class="id" type="var">n</span> : <span class="id" type="var">nat</span>) : <span class="id" type="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="var">n</span> = 3.<br/>
<span class="id" type="keyword">Check</span> <span class="id" type="var">is_three</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;nat&nbsp;-&gt;&nbsp;Prop&nbsp;*)</span><br/>
</div>

<div class="doc">
在Coq中，我们说那些返回一个命题的函数 <i>'定义了它们所取的参数的性质'</i> 。
    以下面这个多态函数为例子；它描述了 <i>'单射函数'</i> 这个十分常见的概念。 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">injective</span> {<span class="id" type="var">A</span> <span class="id" type="var">B</span>} (<span class="id" type="var">f</span> : <span class="id" type="var">A</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">B</span>) :=<br/>
&nbsp;&nbsp;<span style="font-family: arial;">&forall;</span><span class="id" type="var">x</span> <span class="id" type="var">y</span> : <span class="id" type="var">A</span>, <span class="id" type="var">f</span> <span class="id" type="var">x</span> = <span class="id" type="var">f</span> <span class="id" type="var">y</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">x</span> = <span class="id" type="var">y</span>.<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">succ_inj</span> : <span class="id" type="var">injective</span> <span class="id" type="var">S</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">inversion</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
相等性操作符 <span class="inlinecode">=</span> 也是一个返回命题的函数：<span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">m</span></span>是使用了Coq
    的<span class="inlinecode"><span class="id" type="keyword">Notation</span></span>机制定义的<span class="inlinecode"><span class="id" type="var">eq</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode"><span class="id" type="var">m</span></span>的语法糖。因为<span class="inlinecode"><span class="id" type="var">eq</span></span>可以用在任意类型的
    值上，所以它也是多态的：
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Check</span> @<span class="id" type="var">eq</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;forall&nbsp;A&nbsp;:&nbsp;Type,&nbsp;A&nbsp;-&gt;&nbsp;A&nbsp;-&gt;&nbsp;Prop&nbsp;*)</span><br/>
</div>

<div class="doc">
    （注意在上面我们写的是<span class="inlinecode">@<span class="id" type="var">eq</span></span>而不是<span class="inlinecode"><span class="id" type="var">eq</span></span>；<span class="inlinecode"><span class="id" type="var">eq</span></span>的类型参数<span class="inlinecode"><span class="id" type="var">A</span></span>被定义成了
    隐式参数，所以为了看到<span class="inlinecode"><span class="id" type="var">eq</span></span>的完整的类型，我们需要通过<span class="inlinecode">@</span>暂时取消对隐
    式参数的处理。 
</div>

<div class="doc">
<a name="lab158"></a><h1 class="section">逻辑连接符</h1>

<div class="paragraph"> </div>

<a name="lab159"></a><h2 class="section">合取（逻辑"与"）</h2>

<div class="paragraph"> </div>

 命题<span class="inlinecode"><span class="id" type="var">A</span></span>与<span class="inlinecode"><span class="id" type="var">B</span></span>的 <i>'合取'</i> 或 <i>'逻辑与'</i> 写作<span class="inlinecode"><span class="id" type="var">A</span></span> <span class="inlinecode"><span style="font-family: arial;">&and;</span></span> <span class="inlinecode"><span class="id" type="var">B</span></span>，表示一个宣称<span class="inlinecode"><span class="id" type="var">A</span></span>和<span class="inlinecode"><span class="id" type="var">B</span></span>都
    为真的命题。 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">and_example</span> : 3 + 4 = 7 <span style="font-family: arial;">&and;</span> 2 * 2 = 4.<br/>
</div>

<div class="doc">
证明合取命题一般用<span class="inlinecode"><span class="id" type="tactic">split</span></span>这一证明策略；它会分别为组成合取的两个部分生成
    子目标。 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;WORKED&nbsp;IN&nbsp;CLASS&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" type="tactic">split</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;3&nbsp;+&nbsp;4&nbsp;=&nbsp;7&nbsp;*)</span> <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;2&nbsp;+&nbsp;2&nbsp;=&nbsp;4&nbsp;*)</span> <span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
对于任意的命题<span class="inlinecode"><span class="id" type="var">A</span></span>和<span class="inlinecode"><span class="id" type="var">B</span></span>，如果我们假设<span class="inlinecode"><span class="id" type="var">A</span></span>为真而且我们也假设<span class="inlinecode"><span class="id" type="var">B</span></span>为真，那么我
    们能够得出<span class="inlinecode"><span class="id" type="var">A</span></span> <span class="inlinecode"><span style="font-family: arial;">&and;</span></span> <span class="inlinecode"><span class="id" type="var">B</span></span>也为真的结论。
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">and_intro</span> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">A</span> <span class="id" type="var">B</span> : <span class="id" type="keyword">Prop</span>, <span class="id" type="var">A</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">B</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">A</span> <span style="font-family: arial;">&and;</span> <span class="id" type="var">B</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">A</span> <span class="id" type="var">B</span> <span class="id" type="var">HA</span> <span class="id" type="var">HB</span>. <span class="id" type="tactic">split</span>.<br/>
&nbsp;&nbsp;- <span class="id" type="tactic">apply</span> <span class="id" type="var">HA</span>.<br/>
&nbsp;&nbsp;- <span class="id" type="tactic">apply</span> <span class="id" type="var">HB</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
因为定理的应用会产生与假设的个数相等的子目标，我们能够通过应用<span class="inlinecode"><span class="id" type="var">and_intro</span></span>
    来得到与使用<span class="inlinecode"><span class="id" type="tactic">split</span></span>一样的结果。
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">and_example'</span> : 3 + 4 = 7 <span style="font-family: arial;">&and;</span> 2 * 2 = 4.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <span class="id" type="var">and_intro</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;3&nbsp;+&nbsp;4&nbsp;=&nbsp;7&nbsp;*)</span> <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;2&nbsp;+&nbsp;2&nbsp;=&nbsp;4&nbsp;*)</span> <span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a name="lab160"></a><h4 class="section">Exercise: 2 stars (and_exercise)</h4>

</div>
<div class="code code-space">
<span class="id" type="keyword">Example</span> <span class="id" type="var">and_exercise</span> :<br/>
&nbsp;&nbsp;<span style="font-family: arial;">&forall;</span><span class="id" type="var">n</span> <span class="id" type="var">m</span> : <span class="id" type="var">nat</span>, <span class="id" type="var">n</span> + <span class="id" type="var">m</span> = 0 <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">n</span> = 0 <span style="font-family: arial;">&and;</span> <span class="id" type="var">m</span> = 0.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

 以上就是与证明合取有关的内容。在进行相反方向的操作，即在证明过程中需要 <i>'使用'</i> 
    某个合取假设的时候，一般使用<span class="inlinecode"><span class="id" type="tactic">destruct</span></span>。
    如果当前证明上下文中存在形如<span class="inlinecode"><span class="id" type="var">A</span></span> <span class="inlinecode"><span style="font-family: arial;">&and;</span></span> <span class="inlinecode"><span class="id" type="var">B</span></span>的假设<span class="inlinecode"><span class="id" type="var">H</span></span>，<span class="inlinecode"><span class="id" type="tactic">destruct</span></span> <span class="inlinecode"><span class="id" type="var">H</span></span> <span class="inlinecode"><span class="id" type="keyword">as</span></span> <span class="inlinecode">[<span class="id" type="var">HA</span></span> <span class="inlinecode"><span class="id" type="var">HB</span>]</span>将会从上
    下文中去掉<span class="inlinecode"><span class="id" type="var">H</span></span>并增加<span class="inlinecode"><span class="id" type="var">HA</span></span>和<span class="inlinecode"><span class="id" type="var">HB</span></span>这两个新的假设，其中前者宣称<span class="inlinecode"><span class="id" type="var">A</span></span>为真，而后者宣称<span class="inlinecode"><span class="id" type="var">B</span></span>
    为真。 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">and_example2</span> :<br/>
&nbsp;&nbsp;<span style="font-family: arial;">&forall;</span><span class="id" type="var">n</span> <span class="id" type="var">m</span> : <span class="id" type="var">nat</span>, <span class="id" type="var">n</span> = 0 <span style="font-family: arial;">&and;</span> <span class="id" type="var">m</span> = 0 <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">n</span> + <span class="id" type="var">m</span> = 0.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;WORKED&nbsp;IN&nbsp;CLASS&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span> <span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">destruct</span> <span class="id" type="var">H</span> <span class="id" type="keyword">as</span> [<span class="id" type="var">Hn</span> <span class="id" type="var">Hm</span>].<br/>
&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> <span class="id" type="var">Hn</span>. <span class="id" type="tactic">rewrite</span> <span class="id" type="var">Hm</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
我们也能够在将<span class="inlinecode"><span class="id" type="var">H</span></span>引入当前上下文的同时对其进行解构： 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">and_example2'</span> :<br/>
&nbsp;&nbsp;<span style="font-family: arial;">&forall;</span><span class="id" type="var">n</span> <span class="id" type="var">m</span> : <span class="id" type="var">nat</span>, <span class="id" type="var">n</span> = 0 <span style="font-family: arial;">&and;</span> <span class="id" type="var">m</span> = 0 <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">n</span> + <span class="id" type="var">m</span> = 0.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span> [<span class="id" type="var">Hn</span> <span class="id" type="var">Hm</span>].<br/>
&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> <span class="id" type="var">Hn</span>. <span class="id" type="tactic">rewrite</span> <span class="id" type="var">Hm</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
也许你会想，我们完全可以将<span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode">0</span>和<span class="inlinecode"><span class="id" type="var">m</span></span> <span class="inlinecode">=</span> <span class="inlinecode">0</span>写成分开的两个假设，为什么
    我们仍然要不厌其烦地将这两个假设包在一个单独的合取之中呢？
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">and_example2''</span> :<br/>
&nbsp;&nbsp;<span style="font-family: arial;">&forall;</span><span class="id" type="var">n</span> <span class="id" type="var">m</span> : <span class="id" type="var">nat</span>, <span class="id" type="var">n</span> = 0 <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">m</span> = 0 <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">n</span> + <span class="id" type="var">m</span> = 0.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span> <span class="id" type="var">Hn</span> <span class="id" type="var">Hm</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> <span class="id" type="var">Hn</span>. <span class="id" type="tactic">rewrite</span> <span class="id" type="var">Hm</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
单纯地就这个定理而言两种都可以，但是我们需要理解如何对合取假设进行操作，
    因为这样的假设经常在证明的中途出现，特别是在进行较为大型的开发的时候。
    这里就有这样的一个比较简单的例子： 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">and_example3</span> :<br/>
&nbsp;&nbsp;<span style="font-family: arial;">&forall;</span><span class="id" type="var">n</span> <span class="id" type="var">m</span> : <span class="id" type="var">nat</span>, <span class="id" type="var">n</span> + <span class="id" type="var">m</span> = 0 <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">n</span> * <span class="id" type="var">m</span> = 0.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span> <span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">assert</span> (<span class="id" type="var">H'</span> : <span class="id" type="var">n</span> = 0 <span style="font-family: arial;">&and;</span> <span class="id" type="var">m</span> = 0).<br/>
&nbsp;&nbsp;{ <span class="id" type="tactic">apply</span> <span class="id" type="var">and_exercise</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">H</span>. }<br/>
&nbsp;&nbsp;<span class="id" type="tactic">destruct</span> <span class="id" type="var">H'</span> <span class="id" type="keyword">as</span> [<span class="id" type="var">Hn</span> <span class="id" type="var">Hm</span>].<br/>
&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> <span class="id" type="var">Hn</span>. <span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
另外一个经常碰见的场合，就是我们已经知道了<span class="inlinecode"><span class="id" type="var">A</span></span> <span class="inlinecode"><span style="font-family: arial;">&and;</span></span> <span class="inlinecode"><span class="id" type="var">B</span></span>，但是我们只需要<span class="inlinecode"><span class="id" type="var">A</span></span>或
    者<span class="inlinecode"><span class="id" type="var">B</span></span>的时候。以下的引理对于应付这样的状况而言会很有用： 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">proj1</span> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">P</span> <span class="id" type="var">Q</span> : <span class="id" type="keyword">Prop</span>,<br/>
&nbsp;&nbsp;<span class="id" type="var">P</span> <span style="font-family: arial;">&and;</span> <span class="id" type="var">Q</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">P</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span> [<span class="id" type="var">HP</span> <span class="id" type="var">HQ</span>].<br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <span class="id" type="var">HP</span>. <span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a name="lab161"></a><h4 class="section">Exercise: 1 star, optional (proj2)</h4>

</div>
<div class="code code-space">
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">proj2</span> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">P</span> <span class="id" type="var">Q</span> : <span class="id" type="keyword">Prop</span>,<br/>
&nbsp;&nbsp;<span class="id" type="var">P</span> <span style="font-family: arial;">&and;</span> <span class="id" type="var">Q</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">Q</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

 最后，我们有时也需要改变由多个命题组成的合取中某些部分所在的位置。以下的
    引理对于应付这样的状况而言会很有用： 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">and_commut</span> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">P</span> <span class="id" type="var">Q</span> : <span class="id" type="keyword">Prop</span>,<br/>
&nbsp;&nbsp;<span class="id" type="var">P</span> <span style="font-family: arial;">&and;</span> <span class="id" type="var">Q</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">Q</span> <span style="font-family: arial;">&and;</span> <span class="id" type="var">P</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;WORKED&nbsp;IN&nbsp;CLASS&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span> [<span class="id" type="var">HP</span> <span class="id" type="var">HQ</span>].<br/>
&nbsp;&nbsp;<span class="id" type="tactic">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="comment">(*&nbsp;left&nbsp;*)</span> <span class="id" type="tactic">apply</span> <span class="id" type="var">HQ</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="comment">(*&nbsp;right&nbsp;*)</span> <span class="id" type="tactic">apply</span> <span class="id" type="var">HP</span>. <span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a name="lab162"></a><h4 class="section">Exercise: 2 stars (and_assoc)</h4>
 （留意一下<span class="inlinecode"><span class="id" type="tactic">intros</span></span>后面所使用的 <i>'嵌套'</i> 的模式是如何将假设<span class="inlinecode"><span class="id" type="var">H</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode"><span style="font-family: arial;">&and;</span></span> <span class="inlinecode">(<span class="id" type="var">Q</span></span> <span class="inlinecode"><span style="font-family: arial;">&and;</span></span> <span class="inlinecode"><span class="id" type="var">R</span>)</span>
    分解为<span class="inlinecode"><span class="id" type="var">HP</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">P</span></span>，<span class="inlinecode"><span class="id" type="var">HQ</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">Q</span></span>和<span class="inlinecode"><span class="id" type="var">HR</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">R</span></span>这三个互相独立的假设的。从那个地方开始完
    成这个证明。） 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">and_assoc</span> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">P</span> <span class="id" type="var">Q</span> <span class="id" type="var">R</span> : <span class="id" type="keyword">Prop</span>,<br/>
&nbsp;&nbsp;<span class="id" type="var">P</span> <span style="font-family: arial;">&and;</span> (<span class="id" type="var">Q</span> <span style="font-family: arial;">&and;</span> <span class="id" type="var">R</span>) <span style="font-family: arial;">&rarr;</span> (<span class="id" type="var">P</span> <span style="font-family: arial;">&and;</span> <span class="id" type="var">Q</span>) <span style="font-family: arial;">&and;</span> <span class="id" type="var">R</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span> <span class="id" type="var">R</span> [<span class="id" type="var">HP</span> [<span class="id" type="var">HQ</span> <span class="id" type="var">HR</span>]].<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

 顺带一提，<span class="inlinecode"><span style="font-family: arial;">&and;</span></span>这一中缀记号只是<span class="inlinecode"><span class="id" type="var">and</span></span> <span class="inlinecode"><span class="id" type="var">A</span></span> <span class="inlinecode"><span class="id" type="var">B</span></span>的语法糖而已；<span class="inlinecode"><span class="id" type="var">and</span></span>才是Coq里将两个命题
    合并得到合取命题的操作符。 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Check</span> <span class="id" type="var">and</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;and&nbsp;:&nbsp;Prop&nbsp;-&gt;&nbsp;Prop&nbsp;-&gt;&nbsp;Prop&nbsp;*)</span><br/>
</div>

<div class="doc">
<a name="lab163"></a><h2 class="section">析取</h2>

<div class="paragraph"> </div>

 另外一个重要的连接符是所谓的 <i>'析取'</i> ，或者 <i>'逻辑与'</i> 连接符。对于任意两个命题<span class="inlinecode"><span class="id" type="var">A</span></span>
    和<span class="inlinecode"><span class="id" type="var">B</span></span>，其析取<span class="inlinecode"><span class="id" type="var">A</span></span> <span class="inlinecode"><span style="font-family: arial;">&or;</span></span> <span class="inlinecode"><span class="id" type="var">B</span></span>在<span class="inlinecode"><span class="id" type="var">A</span></span>与<span class="inlinecode"><span class="id" type="var">B</span></span>之中的任意一个命题为真时为真。（或者，我们可以写
    <span class="inlinecode"><span class="id" type="var">or</span></span> <span class="inlinecode"><span class="id" type="var">A</span></span> <span class="inlinecode"><span class="id" type="var">B</span></span>，其中<span class="inlinecode"><span class="id" type="var">or</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="keyword">Prop</span></span> <span class="inlinecode"><span style="font-family: arial;">&rarr;</span></span> <span class="inlinecode"><span class="id" type="keyword">Prop</span></span> <span class="inlinecode"><span style="font-family: arial;">&rarr;</span></span> <span class="inlinecode"><span class="id" type="keyword">Prop</span></span>。）
    使用某个析取假设的时候，我们使用分类讨论；就像对<span class="inlinecode"><span class="id" type="var">nat</span></span>以及其他的数据类型进行分类
    讨论一样，对析取假设进行分类讨论时我们也可以使用像<span class="inlinecode"><span class="id" type="tactic">destruct</span></span>或者<span class="inlinecode"><span class="id" type="tactic">intros</span></span>这样的
    证明策略。以下是一个对析取假设进行分类讨论的例子： 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">or_example</span> :<br/>
&nbsp;&nbsp;<span style="font-family: arial;">&forall;</span><span class="id" type="var">n</span> <span class="id" type="var">m</span> : <span class="id" type="var">nat</span>, <span class="id" type="var">n</span> = 0 <span style="font-family: arial;">&or;</span> <span class="id" type="var">m</span> = 0 <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">n</span> * <span class="id" type="var">m</span> = 0.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;这个模式会自动对<span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode">0</span> <span class="inlinecode"><span style="font-family: arial;">&or;</span></span> <span class="inlinecode"><span class="id" type="var">m</span></span> <span class="inlinecode">=</span> <span class="inlinecode">0</span>作出分类讨论。&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span> [<span class="id" type="var">Hn</span> | <span class="id" type="var">Hm</span>].<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;在这里存在<span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode">0</span>&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> <span class="id" type="var">Hn</span>. <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;在这里存在<span class="inlinecode"><span class="id" type="var">m</span></span> <span class="inlinecode">=</span> <span class="inlinecode">0</span>&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> <span class="id" type="var">Hm</span>. <span class="id" type="tactic">rewrite</span> <span style="font-family: arial;">&larr;</span> <span class="id" type="var">mult_n_O</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
相对应地，要证明某个析取命题为真，我们需要证明它任意一边的命题为真。我们用<span class="inlinecode"><span class="id" type="var">left</span></span>
    和<span class="inlinecode"><span class="id" type="var">right</span></span>这两种证明策略来作出这种选择。就像它们的名字所说的那样，<span class="inlinecode"><span class="id" type="var">left</span></span>将会选择
    待证的析取命题的左边，而<span class="inlinecode"><span class="id" type="var">right</span></span>将会选择右边。
    下面是一个很简单的例子：
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">or_intro</span> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">A</span> <span class="id" type="var">B</span> : <span class="id" type="keyword">Prop</span>, <span class="id" type="var">A</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">A</span> <span style="font-family: arial;">&or;</span> <span class="id" type="var">B</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">A</span> <span class="id" type="var">B</span> <span class="id" type="var">HA</span>.<br/>
&nbsp;&nbsp;<span class="id" type="var">left</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <span class="id" type="var">HA</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
这个更为有趣的例子则需要在同一个证明中使用<span class="inlinecode"><span class="id" type="var">left</span></span>和<span class="inlinecode"><span class="id" type="var">right</span></span>： 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">zero_or_succ</span> :<br/>
&nbsp;&nbsp;<span style="font-family: arial;">&forall;</span><span class="id" type="var">n</span> : <span class="id" type="var">nat</span>, <span class="id" type="var">n</span> = 0 <span style="font-family: arial;">&or;</span> <span class="id" type="var">n</span> = <span class="id" type="var">S</span> (<span class="id" type="var">pred</span> <span class="id" type="var">n</span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> [|<span class="id" type="var">n</span>].<br/>
&nbsp;&nbsp;- <span class="id" type="var">left</span>. <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="id" type="var">right</span>. <span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a name="lab164"></a><h4 class="section">Exercise: 1 star (mult_eq_0)</h4>

</div>
<div class="code code-space">
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">mult_eq_0</span> :<br/>
&nbsp;&nbsp;<span style="font-family: arial;">&forall;</span><span class="id" type="var">n</span> <span class="id" type="var">m</span>, <span class="id" type="var">n</span> * <span class="id" type="var">m</span> = 0 <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">n</span> = 0 <span style="font-family: arial;">&or;</span> <span class="id" type="var">m</span> = 0.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

<a name="lab165"></a><h4 class="section">Exercise: 1 star (or_commut)</h4>

</div>
<div class="code code-space">
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">or_commut</span> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">P</span> <span class="id" type="var">Q</span> : <span class="id" type="keyword">Prop</span>,<br/>
&nbsp;&nbsp;<span class="id" type="var">P</span> <span style="font-family: arial;">&or;</span> <span class="id" type="var">Q</span>  <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">Q</span> <span style="font-family: arial;">&or;</span> <span class="id" type="var">P</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

<a name="lab166"></a><h2 class="section">假命题与否定</h2>

<div class="paragraph"> </div>

 到现在为止我们主要都在证明某些东西 <i>'是真的'</i> ，比如说加法真的符合交换律，
    列表之间的连接真的符合结合律等等；我们当然也有可能对一些 <i>'否定'</i> 的，证明
    了某些命题 <i>'并非为真'</i> 的事物产生兴趣。在Coq中，我们使用否定操作符<span class="inlinecode">¬</span>否定
    某个命题。
    为了理解否定背后的原理，回想一下在<a href="Tactics.html"><span class="inlineref">Tactics</span></a>一章中有关 <i>'爆炸原理'</i> 的
    相关讨论；爆炸原理断言，当我们假设了矛盾的存在时，我们可以证明任意命题。
    遵循着这一直觉，我们可以将<span class="inlinecode">¬</span> <span class="inlinecode"><span class="id" type="var">P</span></span>（即“非<span class="inlinecode"><span class="id" type="var">P</span></span>”）定义为<span class="inlinecode"><span style="font-family: arial;">&forall;</span></span> <span class="inlinecode"><span class="id" type="var">Q</span>,</span> <span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode"><span style="font-family: arial;">&rarr;</span></span> <span class="inlinecode"><span class="id" type="var">Q</span></span>；
    但Coq选择了另外一种稍微有些不同的做法：它将<span class="inlinecode">¬</span> <span class="inlinecode"><span class="id" type="var">P</span></span>定义为<span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode"><span style="font-family: arial;">&rarr;</span></span> <span class="inlinecode"><span class="id" type="var">False</span></span>，而
    <span class="inlinecode"><span class="id" type="var">False</span></span>是在标准库中 <i>'被特别地定义了的'</i> 矛盾性的命题。 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Module</span> <span class="id" type="var">MyNot</span>.<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">not</span> (<span class="id" type="var">P</span>:<span class="id" type="keyword">Prop</span>) := <span class="id" type="var">P</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">False</span>.<br/>
<span class="id" type="keyword">Notation</span> "¬ x" := (<span class="id" type="var">not</span> <span class="id" type="var">x</span>) : <span class="id" type="var">type_scope</span>.<br/>
<span class="id" type="keyword">Check</span> <span class="id" type="var">not</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;Prop&nbsp;-&gt;&nbsp;Prop&nbsp;*)</span><br/>
<span class="id" type="keyword">End</span> <span class="id" type="var">MyNot</span>.<br/>
</div>

<div class="doc">
因为<span class="inlinecode"><span class="id" type="var">False</span></span>是矛盾性的命题，我们也可以对其应用爆炸原理：如果我们在证明上下文
    中得到了一个<span class="inlinecode"><span class="id" type="var">False</span></span>，我们可以<span class="inlinecode"><span class="id" type="tactic">destruct</span></span>它，并证明任何当前待证明的目标。 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">ex_falso_quodlibet</span> : <span style="font-family: arial;">&forall;</span>(<span class="id" type="var">P</span>:<span class="id" type="keyword">Prop</span>),<br/>
&nbsp;&nbsp;<span class="id" type="var">False</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">P</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;WORKED&nbsp;IN&nbsp;CLASS&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">P</span> <span class="id" type="var">contra</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">destruct</span> <span class="id" type="var">contra</span>. <span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
    <i>Ex falso quodlibet</i> 是拉丁文，意思是“从谬误出发你能够证明任何你想要的”；
    这是爆炸原理的另一个为人熟知的名字。 
<div class="paragraph"> </div>

<a name="lab167"></a><h4 class="section">Exercise: 2 stars, optional (not_implies_our_not)</h4>
 证明对于任意命题<span class="inlinecode"><span class="id" type="var">P</span></span>，从Coq对于<span class="inlinecode">¬</span> <span class="inlinecode"><span class="id" type="var">P</span></span>的定义能够推出上面提到的对于否定的定义。 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Fact</span> <span class="id" type="var">not_implies_our_not</span> : <span style="font-family: arial;">&forall;</span>(<span class="id" type="var">P</span>:<span class="id" type="keyword">Prop</span>),<br/>
&nbsp;&nbsp;¬ <span class="id" type="var">P</span> <span style="font-family: arial;">&rarr;</span> (<span style="font-family: arial;">&forall;</span>(<span class="id" type="var">Q</span>:<span class="id" type="keyword">Prop</span>), <span class="id" type="var">P</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">Q</span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

 以下是我们用<span class="inlinecode"><span class="id" type="var">not</span></span>宣称并证明“<span class="inlinecode">0</span>和<span class="inlinecode">1</span>是不同的<span class="inlinecode"><span class="id" type="var">nat</span></span>”这一命题的做法： 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">zero_not_one</span> : ~(0 = 1).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">contra</span>. <span class="id" type="tactic">inversion</span> <span class="id" type="var">contra</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
这样的有关不相等的命题出现得十分频繁，足以让我们为其定义一个独立的表示法：
    <span class="inlinecode"><span class="id" type="var">x</span></span> <span class="inlinecode">≠</span> <span class="inlinecode"><span class="id" type="var">y</span></span>。 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Check</span> (0 ≠ 1).<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;Prop&nbsp;*)</span><br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">zero_not_one'</span> : 0 ≠ 1.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">inversion</span> <span class="id" type="var">H</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
在能够熟练地在Coq中对否定命题进行操作之前确实需要一点练习：即使有时你已经很
    清楚为什么某个否定命题为真，刚开始试图通过适当的设置让Coq接受这一点可能也会
    稍微有些困难。以下是一些作为热身的有关一些常见的事实的证明：
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">not_False</span> :<br/>
&nbsp;&nbsp;¬ <span class="id" type="var">False</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">unfold</span> <span class="id" type="var">not</span>. <span class="id" type="tactic">intros</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">destruct</span> <span class="id" type="var">H</span>. <span class="id" type="keyword">Qed</span>.<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">contradiction_implies_anything</span> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">P</span> <span class="id" type="var">Q</span> : <span class="id" type="keyword">Prop</span>,<br/>
&nbsp;&nbsp;(<span class="id" type="var">P</span> <span style="font-family: arial;">&and;</span> ¬<span class="id" type="var">P</span>) <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">Q</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;WORKED&nbsp;IN&nbsp;CLASS&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span> [<span class="id" type="var">HP</span> <span class="id" type="var">HNA</span>]. <span class="id" type="tactic">unfold</span> <span class="id" type="var">not</span> <span class="id" type="keyword">in</span> <span class="id" type="var">HNA</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <span class="id" type="var">HNA</span> <span class="id" type="keyword">in</span> <span class="id" type="var">HP</span>. <span class="id" type="tactic">destruct</span> <span class="id" type="var">HP</span>. <span class="id" type="keyword">Qed</span>.<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">double_neg</span> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">P</span> : <span class="id" type="keyword">Prop</span>,<br/>
&nbsp;&nbsp;<span class="id" type="var">P</span> <span style="font-family: arial;">&rarr;</span> ~~<span class="id" type="var">P</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;WORKED&nbsp;IN&nbsp;CLASS&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">P</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">unfold</span> <span class="id" type="var">not</span>. <span class="id" type="tactic">intros</span> <span class="id" type="var">G</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">G</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">H</span>. <span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a name="lab168"></a><h4 class="section">Exercise: 2 stars, advanced, recommendedM (double_neg_inf)</h4>
 写出<span class="inlinecode"><span class="id" type="var">double_neg</span></span>，即下述命题的一个非形式化的证明：
    命题：对任意命题<span class="inlinecode"><span class="id" type="var">P</span></span>而言，<span class="inlinecode"><span class="id" type="var">P</span></span>蕴含<span class="inlinecode">~~<span class="id" type="var">P</span></span>。 
</div>
<div class="code code-tight">

<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

<a name="lab169"></a><h4 class="section">Exercise: 2 stars, recommended (contrapositive)</h4>

</div>
<div class="code code-space">
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">contrapositive</span> : <span style="font-family: arial;">&forall;</span>(<span class="id" type="var">P</span> <span class="id" type="var">Q</span> : <span class="id" type="keyword">Prop</span>),<br/>
&nbsp;&nbsp;(<span class="id" type="var">P</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">Q</span>) <span style="font-family: arial;">&rarr;</span> (¬<span class="id" type="var">Q</span> <span style="font-family: arial;">&rarr;</span> ¬<span class="id" type="var">P</span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

<a name="lab170"></a><h4 class="section">Exercise: 1 star (not_both_true_and_false)</h4>

</div>
<div class="code code-space">
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">not_both_true_and_false</span> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">P</span> : <span class="id" type="keyword">Prop</span>,<br/>
&nbsp;&nbsp;¬ (<span class="id" type="var">P</span> <span style="font-family: arial;">&and;</span> ¬<span class="id" type="var">P</span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

<a name="lab171"></a><h4 class="section">Exercise: 1 star, advancedM (informal_not_PNP)</h4>
 写出<span class="inlinecode"><span style="font-family: arial;">&forall;</span></span> <span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="keyword">Prop</span>,</span> <span class="inlinecode">¬</span> <span class="inlinecode">(<span class="id" type="var">P</span></span> <span class="inlinecode"><span style="font-family: arial;">&and;</span></span> <span class="inlinecode">¬<span class="id" type="var">P</span>)</span>这一命题的非形式化的证明。你可以使用
    任何你想用的自然语言。 
</div>
<div class="code code-tight">

<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

 类似地，因为不等式包含了一个否定，在能够熟练地使用它之前也需要一定的练习。
    这里是一个比较有用的小技巧：如果你需要证明某个不可能的目标（例如当前的子目
    标是<span class="inlinecode"><span class="id" type="var">false</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">true</span></span>）时，用<span class="inlinecode"><span class="id" type="var">ex_falso_quodlibet</span></span>将这个目标转换成<span class="inlinecode"><span class="id" type="var">False</span></span>；
    如果当前的证明上下文中存在形如<span class="inlinecode">¬<span class="id" type="var">P</span></span>的假设（例如形如<span class="inlinecode"><span class="id" type="var">x</span>≠<span class="id" type="var">y</span></span>的假设），那么这会
    让这些假设的使用变得更容易些。
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">not_true_is_false</span> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">b</span> : <span class="id" type="var">bool</span>,<br/>
&nbsp;&nbsp;<span class="id" type="var">b</span> ≠ <span class="id" type="var">true</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">b</span> = <span class="id" type="var">false</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> [] <span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;b&nbsp;=&nbsp;true&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">unfold</span> <span class="id" type="var">not</span> <span class="id" type="keyword">in</span> <span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <span class="id" type="var">ex_falso_quodlibet</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;b&nbsp;=&nbsp;false&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
因为我们经常会用到<span class="inlinecode"><span class="id" type="var">ex_falso_quodlibet</span></span>，所以Coq提供了一个内置的证明策略：
    <span class="inlinecode"><span class="id" type="var">exfalso</span></span>；这个策略在被使用时相当于应用了<span class="inlinecode"><span class="id" type="var">ex_falso_quodlibet</span></span>。
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">not_true_is_false'</span> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">b</span> : <span class="id" type="var">bool</span>,<br/>
&nbsp;&nbsp;<span class="id" type="var">b</span> ≠ <span class="id" type="var">true</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">b</span> = <span class="id" type="var">false</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> [] <span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;b&nbsp;=&nbsp;false&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">unfold</span> <span class="id" type="var">not</span> <span class="id" type="keyword">in</span> <span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">exfalso</span>. <span class="comment">(*&nbsp;&lt;===&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;b&nbsp;=&nbsp;true&nbsp;*)</span> <span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a name="lab172"></a><h2 class="section">真值</h2>

<div class="paragraph"> </div>

 除了<span class="inlinecode"><span class="id" type="var">False</span></span>以外，Coq的标准库中也定义了<span class="inlinecode"><span class="id" type="var">True</span></span>这一十分容易就能证明的命题。
    我们用<span class="inlinecode"><span class="id" type="var">I</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">True</span></span>这一事先定义了的常数来证明<span class="inlinecode"><span class="id" type="var">True</span></span>： 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">True_is_true</span> : <span class="id" type="var">True</span>.<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">I</span>. <span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
与经常被使用的<span class="inlinecode"><span class="id" type="var">False</span></span>不同，因为证明过于简单（所以也就没什么足以引起兴趣的
    东西）而且并不携带任何有用的信息，<span class="inlinecode"><span class="id" type="var">True</span></span>很少被使用。
    然而在使用条件从句构建更加复杂的<span class="inlinecode"><span class="id" type="keyword">Prop</span></span>或者作为高阶<span class="inlinecode"><span class="id" type="keyword">Prop</span></span>的一个参数的时候它
    也可以变得十分有用。以后我们将会看到<span class="inlinecode"><span class="id" type="var">True</span></span>的这类用法。

<div class="paragraph"> </div>

<a name="lab173"></a><h2 class="section">逻辑上的相等性 Logical Equivalence</h2>

<div class="paragraph"> </div>

 “当且仅当”这一逻辑连接符用起来十分顺手；它是两个蕴含式的合取，声明两个命题
    在任何情况下都有着相同的真值。 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Module</span> <span class="id" type="var">MyIff</span>.<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">iff</span> (<span class="id" type="var">P</span> <span class="id" type="var">Q</span> : <span class="id" type="keyword">Prop</span>) := (<span class="id" type="var">P</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">Q</span>) <span style="font-family: arial;">&and;</span> (<span class="id" type="var">Q</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">P</span>).<br/>
<span class="id" type="keyword">Notation</span> "P <span style="font-family: arial;">&harr;</span> Q" := (<span class="id" type="var">iff</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="tactic">at</span> <span class="id" type="var">level</span> 95, <span class="id" type="var">no</span> <span class="id" type="var">associativity</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" type="var">type_scope</span>.<br/>
<span class="id" type="keyword">End</span> <span class="id" type="var">MyIff</span>.<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">iff_sym</span> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">P</span> <span class="id" type="var">Q</span> : <span class="id" type="keyword">Prop</span>,<br/>
&nbsp;&nbsp;(<span class="id" type="var">P</span> <span style="font-family: arial;">&harr;</span> <span class="id" type="var">Q</span>) <span style="font-family: arial;">&rarr;</span> (<span class="id" type="var">Q</span> <span style="font-family: arial;">&harr;</span> <span class="id" type="var">P</span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;WORKED&nbsp;IN&nbsp;CLASS&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span> [<span class="id" type="var">HAB</span> <span class="id" type="var">HBA</span>].<br/>
&nbsp;&nbsp;<span class="id" type="tactic">split</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;-&gt;&nbsp;*)</span> <span class="id" type="tactic">apply</span> <span class="id" type="var">HBA</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;&lt;-&nbsp;*)</span> <span class="id" type="tactic">apply</span> <span class="id" type="var">HAB</span>. <span class="id" type="keyword">Qed</span>.<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">not_true_iff_false</span> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">b</span>,<br/>
&nbsp;&nbsp;<span class="id" type="var">b</span> ≠ <span class="id" type="var">true</span> <span style="font-family: arial;">&harr;</span> <span class="id" type="var">b</span> = <span class="id" type="var">false</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;WORKED&nbsp;IN&nbsp;CLASS&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">b</span>. <span class="id" type="tactic">split</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;-&gt;&nbsp;*)</span> <span class="id" type="tactic">apply</span> <span class="id" type="var">not_true_is_false</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;&lt;-&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">rewrite</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">intros</span> <span class="id" type="var">H'</span>. <span class="id" type="tactic">inversion</span> <span class="id" type="var">H'</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a name="lab174"></a><h4 class="section">Exercise: 1 star, optional (iff_properties)</h4>
 以上面的<span class="inlinecode"><span style="font-family: arial;">&harr;</span></span>的对称性（<span class="inlinecode"><span class="id" type="var">iff_sym</span></span>）的证明作为参照，证明<span class="inlinecode"><span style="font-family: arial;">&harr;</span></span>同时也
    有自反性和传递性。 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">iff_refl</span> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">P</span> : <span class="id" type="keyword">Prop</span>,<br/>
&nbsp;&nbsp;<span class="id" type="var">P</span> <span style="font-family: arial;">&harr;</span> <span class="id" type="var">P</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">iff_trans</span> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">P</span> <span class="id" type="var">Q</span> <span class="id" type="var">R</span> : <span class="id" type="keyword">Prop</span>,<br/>
&nbsp;&nbsp;(<span class="id" type="var">P</span> <span style="font-family: arial;">&harr;</span> <span class="id" type="var">Q</span>) <span style="font-family: arial;">&rarr;</span> (<span class="id" type="var">Q</span> <span style="font-family: arial;">&harr;</span> <span class="id" type="var">R</span>) <span style="font-family: arial;">&rarr;</span> (<span class="id" type="var">P</span> <span style="font-family: arial;">&harr;</span> <span class="id" type="var">R</span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

<a name="lab175"></a><h4 class="section">Exercise: 3 stars (or_distributes_over_and)</h4>

</div>
<div class="code code-space">
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">or_distributes_over_and</span> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">P</span> <span class="id" type="var">Q</span> <span class="id" type="var">R</span> : <span class="id" type="keyword">Prop</span>,<br/>
&nbsp;&nbsp;<span class="id" type="var">P</span> <span style="font-family: arial;">&or;</span> (<span class="id" type="var">Q</span> <span style="font-family: arial;">&and;</span> <span class="id" type="var">R</span>) <span style="font-family: arial;">&harr;</span> (<span class="id" type="var">P</span> <span style="font-family: arial;">&or;</span> <span class="id" type="var">Q</span>) <span style="font-family: arial;">&and;</span> (<span class="id" type="var">P</span> <span style="font-family: arial;">&or;</span> <span class="id" type="var">R</span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

 Coq的某些证明策略会以特别的方式处理<span class="inlinecode"><span class="id" type="var">iff</span></span>，并以此避免了某些底层的对证明
    状态的操作。比如说，<span class="inlinecode"><span class="id" type="tactic">rewrite</span></span>和<span class="inlinecode"><span class="id" type="tactic">reflexivity</span></span>除了可以对等式使用以外同样
    也可以对<span class="inlinecode"><span class="id" type="var">iff</span></span>使用。你需要加载一个特别的Coq库来让Coq允许你使用等式以外的
    式子进行重写。 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Import</span> <span class="id" type="var">Coq.Setoids.Setoid</span>.<br/>
</div>

<div class="doc">
以下是一个简单的例子；它展示了这些证明策略会如何使用<span class="inlinecode"><span class="id" type="var">iff</span></span>。
    首先，先让我们证明一些比较基本的<span class="inlinecode"><span class="id" type="var">iff</span></span>等价命题…… 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">mult_0</span> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">n</span> <span class="id" type="var">m</span>, <span class="id" type="var">n</span> * <span class="id" type="var">m</span> = 0 <span style="font-family: arial;">&harr;</span> <span class="id" type="var">n</span> = 0 <span style="font-family: arial;">&or;</span> <span class="id" type="var">m</span> = 0.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">split</span>.<br/>
&nbsp;&nbsp;- <span class="id" type="tactic">apply</span> <span class="id" type="var">mult_eq_0</span>.<br/>
&nbsp;&nbsp;- <span class="id" type="tactic">apply</span> <span class="id" type="var">or_example</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">or_assoc</span> :<br/>
&nbsp;&nbsp;<span style="font-family: arial;">&forall;</span><span class="id" type="var">P</span> <span class="id" type="var">Q</span> <span class="id" type="var">R</span> : <span class="id" type="keyword">Prop</span>, <span class="id" type="var">P</span> <span style="font-family: arial;">&or;</span> (<span class="id" type="var">Q</span> <span style="font-family: arial;">&or;</span> <span class="id" type="var">R</span>) <span style="font-family: arial;">&harr;</span> (<span class="id" type="var">P</span> <span style="font-family: arial;">&or;</span> <span class="id" type="var">Q</span>) <span style="font-family: arial;">&or;</span> <span class="id" type="var">R</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span> <span class="id" type="var">R</span>. <span class="id" type="tactic">split</span>.<br/>
&nbsp;&nbsp;- <span class="id" type="tactic">intros</span> [<span class="id" type="var">H</span> | [<span class="id" type="var">H</span> | <span class="id" type="var">H</span>]].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" type="var">left</span>. <span class="id" type="var">left</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" type="var">left</span>. <span class="id" type="var">right</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" type="var">right</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;- <span class="id" type="tactic">intros</span> [[<span class="id" type="var">H</span> | <span class="id" type="var">H</span>] | <span class="id" type="var">H</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" type="var">left</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" type="var">right</span>. <span class="id" type="var">left</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" type="var">right</span>. <span class="id" type="var">right</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">H</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
现在我们能够在某些与等价性相关的命题的证明中使用<span class="inlinecode"><span class="id" type="tactic">rewrite</span></span>和<span class="inlinecode"><span class="id" type="tactic">reflexivity</span></span>
    的时候使用这些事实。这里是上述的<span class="inlinecode"><span class="id" type="var">mult_0</span></span>的、包含了三个变量的版本： 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">mult_0_3</span> :<br/>
&nbsp;&nbsp;<span style="font-family: arial;">&forall;</span><span class="id" type="var">n</span> <span class="id" type="var">m</span> <span class="id" type="var">p</span>, <span class="id" type="var">n</span> * <span class="id" type="var">m</span> * <span class="id" type="var">p</span> = 0 <span style="font-family: arial;">&harr;</span> <span class="id" type="var">n</span> = 0 <span style="font-family: arial;">&or;</span> <span class="id" type="var">m</span> = 0 <span style="font-family: arial;">&or;</span> <span class="id" type="var">p</span> = 0.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span> <span class="id" type="var">p</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> <span class="id" type="var">mult_0</span>. <span class="id" type="tactic">rewrite</span> <span class="id" type="var">mult_0</span>. <span class="id" type="tactic">rewrite</span> <span class="id" type="var">or_assoc</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" type="tactic">apply</span></span>也可以与<span class="inlinecode"><span style="font-family: arial;">&harr;</span></span>一同使用。当<span class="inlinecode"><span class="id" type="tactic">apply</span></span>的参数是一个等价性命题的证明，它将
    试图猜出使用该命题所包含的哪一个方向的蕴含式。 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">apply_iff_example</span> :<br/>
&nbsp;&nbsp;<span style="font-family: arial;">&forall;</span><span class="id" type="var">n</span> <span class="id" type="var">m</span> : <span class="id" type="var">nat</span>, <span class="id" type="var">n</span> * <span class="id" type="var">m</span> = 0 <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">n</span> = 0 <span style="font-family: arial;">&or;</span> <span class="id" type="var">m</span> = 0.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">mult_0</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">H</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a name="lab176"></a><h2 class="section">存在量化</h2>

<div class="paragraph"> </div>


<div class="paragraph"> </div>

    <i>'存在量化'</i> 也是十分重要的逻辑连接符。我们用<span class="inlinecode"><span style="font-family: arial;">&exist;</span></span> <span class="inlinecode"><span class="id" type="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">T</span>,</span> <span class="inlinecode"><span class="id" type="var">P</span></span>表示存在一些
    类型为<span class="inlinecode"><span class="id" type="var">T</span></span>的<span class="inlinecode"><span class="id" type="var">x</span></span>使得一些性质<span class="inlinecode"><span class="id" type="var">P</span></span>对于<span class="inlinecode"><span class="id" type="var">x</span></span>成立。如果Coq能够从上下文中推断出<span class="inlinecode"><span class="id" type="var">x</span></span>的
    类型应该为<span class="inlinecode"><span class="id" type="var">T</span></span>，那么就像<span class="inlinecode"><span style="font-family: arial;">&forall;</span></span>中我们可以省略<span class="inlinecode"><span class="id" type="var">x</span></span>的类型标注一样，在<span class="inlinecode"><span style="font-family: arial;">&exist;</span></span>中
    我们也可以省略<span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">T</span></span>这一类型标注。 
<div class="paragraph"> </div>

 证明形如<span class="inlinecode"><span style="font-family: arial;">&exist;</span></span> <span class="inlinecode"><span class="id" type="var">x</span>,</span> <span class="inlinecode"><span class="id" type="var">P</span></span>的命题时我们需要证明<span class="inlinecode"><span class="id" type="var">P</span></span>对于一些特定的<span class="inlinecode"><span class="id" type="var">x</span></span>是成立的；这些
    <span class="inlinecode"><span class="id" type="var">x</span></span>被称作证实了这一命题的 <i>'实例'</i> 。证明分为两个步骤：首先用<span class="inlinecode"><span style="font-family: arial;">&exist;</span></span> <span class="inlinecode"><span class="id" type="var">t</span></span>指出
    我们已经知道的可以使<span class="inlinecode"><span class="id" type="var">P</span></span>成立的实例<span class="inlinecode"><span class="id" type="var">t</span></span>，然后我们证明所有<span class="inlinecode"><span class="id" type="var">x</span></span>都被替换成<span class="inlinecode"><span class="id" type="var">t</span></span>的命题
    <span class="inlinecode"><span class="id" type="var">P</span></span>。 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">four_is_even</span> : <span style="font-family: arial;">&exist;</span><span class="id" type="var">n</span> : <span class="id" type="var">nat</span>, 4 = <span class="id" type="var">n</span> + <span class="id" type="var">n</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span style="font-family: arial;">&exist;</span>2. <span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
相反地，如果我们在上下文中有形如<span class="inlinecode"><span style="font-family: arial;">&exist;</span></span> <span class="inlinecode"><span class="id" type="var">x</span>,</span> <span class="inlinecode"><span class="id" type="var">P</span></span>的存在假设，我们可以将其解构得到
    某个实例<span class="inlinecode"><span class="id" type="var">x</span></span>以及证实<span class="inlinecode"><span class="id" type="var">P</span></span>对<span class="inlinecode"><span class="id" type="var">x</span></span>成立的证据。 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">exists_example_2</span> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">n</span>,<br/>
&nbsp;&nbsp;(<span style="font-family: arial;">&exist;</span><span class="id" type="var">m</span>, <span class="id" type="var">n</span> = 4 + <span class="id" type="var">m</span>) <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;(<span style="font-family: arial;">&exist;</span><span class="id" type="var">o</span>, <span class="id" type="var">n</span> = 2 + <span class="id" type="var">o</span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;WORKED&nbsp;IN&nbsp;CLASS&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> [<span class="id" type="var">m</span> <span class="id" type="var">Hm</span>]. <span class="comment">(*&nbsp;note&nbsp;implicit&nbsp;<span class="inlinecode"><span class="id" type="tactic">destruct</span></span>&nbsp;here&nbsp;*)</span><br/>
&nbsp;&nbsp;<span style="font-family: arial;">&exist;</span>(2 + <span class="id" type="var">m</span>).<br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <span class="id" type="var">Hm</span>. <span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a name="lab177"></a><h4 class="section">Exercise: 1 star (dist_not_exists)</h4>
 证明这一命题：如果<span class="inlinecode"><span class="id" type="var">P</span></span>对所有<span class="inlinecode"><span class="id" type="var">x</span></span>成立，那么没有使得<span class="inlinecode"><span class="id" type="var">P</span></span>不成立的<span class="inlinecode"><span class="id" type="var">x</span></span>。 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">dist_not_exists</span> : <span style="font-family: arial;">&forall;</span>(<span class="id" type="var">X</span>:<span class="id" type="keyword">Type</span>) (<span class="id" type="var">P</span> : <span class="id" type="var">X</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="keyword">Prop</span>),<br/>
&nbsp;&nbsp;(<span style="font-family: arial;">&forall;</span><span class="id" type="var">x</span>, <span class="id" type="var">P</span> <span class="id" type="var">x</span>) <span style="font-family: arial;">&rarr;</span> ¬ (<span style="font-family: arial;">&exist;</span><span class="id" type="var">x</span>, ¬ <span class="id" type="var">P</span> <span class="id" type="var">x</span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

<a name="lab178"></a><h4 class="section">Exercise: 2 stars (dist_exists_or)</h4>
 证明存在量化对析取符合分配律。 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">dist_exists_or</span> : <span style="font-family: arial;">&forall;</span>(<span class="id" type="var">X</span>:<span class="id" type="keyword">Type</span>) (<span class="id" type="var">P</span> <span class="id" type="var">Q</span> : <span class="id" type="var">X</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="keyword">Prop</span>),<br/>
&nbsp;&nbsp;(<span style="font-family: arial;">&exist;</span><span class="id" type="var">x</span>, <span class="id" type="var">P</span> <span class="id" type="var">x</span> <span style="font-family: arial;">&or;</span> <span class="id" type="var">Q</span> <span class="id" type="var">x</span>) <span style="font-family: arial;">&harr;</span> (<span style="font-family: arial;">&exist;</span><span class="id" type="var">x</span>, <span class="id" type="var">P</span> <span class="id" type="var">x</span>) <span style="font-family: arial;">&or;</span> (<span style="font-family: arial;">&exist;</span><span class="id" type="var">x</span>, <span class="id" type="var">Q</span> <span class="id" type="var">x</span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<span class="proofbox">&#9744;</span> 

<div class="doc">
<a name="lab179"></a><h1 class="section">在编程中使用命题</h1>

<div class="paragraph"> </div>


<div class="paragraph"> </div>

    我们所了解的逻辑连接符大幅提升了我们以简单的命题为基础构建更为复杂的命题的能力。
    作为例子，让我们来思考如何表示“某个元素<span class="inlinecode"><span class="id" type="var">x</span></span>出现在某个列表<span class="inlinecode"><span class="id" type="var">l</span></span>之中”这一命题。注意到
    这一性质有着很简单的递归结构：
<div class="paragraph"> </div>


<div class="paragraph"> </div>

<ul class="doclist">
<li> 如果<span class="inlinecode"><span class="id" type="var">l</span></span>是空列表，那么<span class="inlinecode"><span class="id" type="var">x</span></span>不可能在<span class="inlinecode"><span class="id" type="var">l</span></span>中出现；所以“<span class="inlinecode"><span class="id" type="var">x</span></span>在<span class="inlinecode"><span class="id" type="var">l</span></span>中出现”应该为假命题。
<ul class="doclist">
<li> 如果<span class="inlinecode"><span class="id" type="var">l</span></span>为形如<span class="inlinecode"><span class="id" type="var">x'</span></span> <span class="inlinecode">::</span> <span class="inlinecode"><span class="id" type="var">l'</span></span>的列表，那么“<span class="inlinecode"><span class="id" type="var">x</span></span>在<span class="inlinecode"><span class="id" type="var">l</span></span>中出现”的正确性取决于<span class="inlinecode"><span class="id" type="var">x</span></span>是否与<span class="inlinecode"><span class="id" type="var">x'</span></span>
      相等或者<span class="inlinecode"><span class="id" type="var">x</span></span>是否在<span class="inlinecode"><span class="id" type="var">l'</span></span>出现。

<div class="paragraph"> </div>


</li>
</ul>
    我们能够将这一定义直接翻译成一个递归函数；这个函数将取一个元素和一个列表作为参数
    并返回一个命题：
</li>
</ul>

</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Fixpoint</span> <span class="id" type="var">In</span> {<span class="id" type="var">A</span> : <span class="id" type="keyword">Type</span>} (<span class="id" type="var">x</span> : <span class="id" type="var">A</span>) (<span class="id" type="var">l</span> : <span class="id" type="var">list</span> <span class="id" type="var">A</span>) : <span class="id" type="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">l</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| [] ⇒ <span class="id" type="var">False</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">x'</span> :: <span class="id" type="var">l'</span> ⇒ <span class="id" type="var">x'</span> = <span class="id" type="var">x</span> <span style="font-family: arial;">&or;</span> <span class="id" type="var">In</span> <span class="id" type="var">x</span> <span class="id" type="var">l'</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>
</div>

<div class="doc">
当<span class="inlinecode"><span class="id" type="var">In</span></span>被应用于某个具体的列表时，它将被展开为一串由具体的命题组成的
    析取式。
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">In_example_1</span> : <span class="id" type="var">In</span> 4 [1; 2; 3; 4; 5].<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;WORKED&nbsp;IN&nbsp;CLASS&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" type="tactic">simpl</span>. <span class="id" type="var">right</span>. <span class="id" type="var">right</span>. <span class="id" type="var">right</span>. <span class="id" type="var">left</span>. <span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">In_example_2</span> :<br/>
&nbsp;&nbsp;<span style="font-family: arial;">&forall;</span><span class="id" type="var">n</span>, <span class="id" type="var">In</span> <span class="id" type="var">n</span> [2; 4] <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;<span style="font-family: arial;">&exist;</span><span class="id" type="var">n'</span>, <span class="id" type="var">n</span> = 2 * <span class="id" type="var">n'</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;WORKED&nbsp;IN&nbsp;CLASS&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" type="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> [<span class="id" type="var">H</span> | [<span class="id" type="var">H</span> | []]].<br/>
&nbsp;&nbsp;- <span style="font-family: arial;">&exist;</span>1. <span class="id" type="tactic">rewrite</span> <span style="font-family: arial;">&larr;</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span style="font-family: arial;">&exist;</span>2. <span class="id" type="tactic">rewrite</span> <span style="font-family: arial;">&larr;</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
（注意，在上面的例子中我们使用了空模式来 <i>'无视'</i> 最后一种情况。） 
<div class="paragraph"> </div>

 我们也可以证明关于<span class="inlinecode"><span class="id" type="var">In</span></span>的一些更为一般的，或者更为高阶的引理。
    注意在下面<span class="inlinecode"><span class="id" type="var">In</span></span>被应用到一个变量上；只有我们对其进行分类讨论的时候，它才会
    被展开。 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">In_map</span> :<br/>
&nbsp;&nbsp;<span style="font-family: arial;">&forall;</span>(<span class="id" type="var">A</span> <span class="id" type="var">B</span> : <span class="id" type="keyword">Type</span>) (<span class="id" type="var">f</span> : <span class="id" type="var">A</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">B</span>) (<span class="id" type="var">l</span> : <span class="id" type="var">list</span> <span class="id" type="var">A</span>) (<span class="id" type="var">x</span> : <span class="id" type="var">A</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">In</span> <span class="id" type="var">x</span> <span class="id" type="var">l</span> <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">In</span> (<span class="id" type="var">f</span> <span class="id" type="var">x</span>) (<span class="id" type="var">map</span> <span class="id" type="var">f</span> <span class="id" type="var">l</span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">A</span> <span class="id" type="var">B</span> <span class="id" type="var">f</span> <span class="id" type="var">l</span> <span class="id" type="var">x</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">induction</span> <span class="id" type="var">l</span> <span class="id" type="keyword">as</span> [|<span class="id" type="var">x'</span> <span class="id" type="var">l'</span> <span class="id" type="var">IHl'</span>].<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;l&nbsp;=&nbsp;nil，矛盾&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">intros</span> [].<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;l&nbsp;=&nbsp;x'&nbsp;::&nbsp;l'&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">intros</span> [<span class="id" type="var">H</span> | <span class="id" type="var">H</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" type="tactic">rewrite</span> <span class="id" type="var">H</span>. <span class="id" type="var">left</span>. <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" type="var">right</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">IHl'</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">H</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
虽然递归地定义命题在某些情况下会十分方便，但是这种方法也有其劣势。比如说，
    作为一种递归函数，这类命题也会受Coq对递归函数的要求的限制：在Coq中递归函数
    必须是“明显可停机”的。在下一章我们将会了解如何 <i>'归纳地'</i> 定义一个命题；这是
    一种与之不同的技巧，有着其独特的优势和劣势。
<div class="paragraph"> </div>

<a name="lab180"></a><h4 class="section">Exercise: 2 stars (In_map_iff)</h4>

</div>
<div class="code code-space">
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">In_map_iff</span> :<br/>
&nbsp;&nbsp;<span style="font-family: arial;">&forall;</span>(<span class="id" type="var">A</span> <span class="id" type="var">B</span> : <span class="id" type="keyword">Type</span>) (<span class="id" type="var">f</span> : <span class="id" type="var">A</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">B</span>) (<span class="id" type="var">l</span> : <span class="id" type="var">list</span> <span class="id" type="var">A</span>) (<span class="id" type="var">y</span> : <span class="id" type="var">B</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">In</span> <span class="id" type="var">y</span> (<span class="id" type="var">map</span> <span class="id" type="var">f</span> <span class="id" type="var">l</span>) <span style="font-family: arial;">&harr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-family: arial;">&exist;</span><span class="id" type="var">x</span>, <span class="id" type="var">f</span> <span class="id" type="var">x</span> = <span class="id" type="var">y</span> <span style="font-family: arial;">&and;</span> <span class="id" type="var">In</span> <span class="id" type="var">x</span> <span class="id" type="var">l</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

<a name="lab181"></a><h4 class="section">Exercise: 2 stars (in_app_iff)</h4>

</div>
<div class="code code-space">
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">in_app_iff</span> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">A</span> <span class="id" type="var">l</span> <span class="id" type="var">l'</span> (<span class="id" type="var">a</span>:<span class="id" type="var">A</span>),<br/>
&nbsp;&nbsp;<span class="id" type="var">In</span> <span class="id" type="var">a</span> (<span class="id" type="var">l</span>++<span class="id" type="var">l'</span>) <span style="font-family: arial;">&harr;</span> <span class="id" type="var">In</span> <span class="id" type="var">a</span> <span class="id" type="var">l</span> <span style="font-family: arial;">&or;</span> <span class="id" type="var">In</span> <span class="id" type="var">a</span> <span class="id" type="var">l'</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

<a name="lab182"></a><h4 class="section">Exercise: 3 stars (All)</h4>
 回忆一下，返回命题的函数能够被视为对其参数的某种 <i>'性质'</i> 的定义。比如说，
    假设<span class="inlinecode"><span class="id" type="var">P</span></span>的类型为<span class="inlinecode"><span class="id" type="var">nat</span></span> <span class="inlinecode"><span style="font-family: arial;">&rarr;</span></span> <span class="inlinecode"><span class="id" type="keyword">Prop</span></span>，那么<span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span>就是声明<span class="inlinecode"><span class="id" type="var">n</span></span>拥有性质<span class="inlinecode"><span class="id" type="var">P</span></span>的命题。
    以<span class="inlinecode"><span class="id" type="var">In</span></span>作为参考，完成<span class="inlinecode"><span class="id" type="var">All</span></span>这一递归函数的定义；它以某个列表<span class="inlinecode"><span class="id" type="var">l</span></span>以及针对其元素
    的性质<span class="inlinecode"><span class="id" type="var">P</span></span>为参数，返回一个声明“<span class="inlinecode"><span class="id" type="var">l</span></span>中全部元素都具有性质<span class="inlinecode"><span class="id" type="var">P</span></span>”的命题。证明<span class="inlinecode"><span class="id" type="var">All_In</span></span>
    这一引理以对你的定义进行测试。当然了，为了通过测试而直接将<span class="inlinecode"><span class="id" type="var">All_In</span></span>的左半部分
    写入<span class="inlinecode"><span class="id" type="var">All</span></span>的定义是 <i>'不被接受的'</i> 。
  
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Fixpoint</span> <span class="id" type="var">All</span> {<span class="id" type="var">T</span> : <span class="id" type="keyword">Type</span>} (<span class="id" type="var">P</span> : <span class="id" type="var">T</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="keyword">Prop</span>) (<span class="id" type="var">l</span> : <span class="id" type="var">list</span> <span class="id" type="var">T</span>) : <span class="id" type="keyword">Prop</span><br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;REPLACE&nbsp;THIS&nbsp;LINE&nbsp;WITH&nbsp;":=&nbsp;_your_definition_&nbsp;."&nbsp;*)</span>. <span class="id" type="var">Admitted</span>.<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">All_In</span> :<br/>
&nbsp;&nbsp;<span style="font-family: arial;">&forall;</span><span class="id" type="var">T</span> (<span class="id" type="var">P</span> : <span class="id" type="var">T</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="keyword">Prop</span>) (<span class="id" type="var">l</span> : <span class="id" type="var">list</span> <span class="id" type="var">T</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span style="font-family: arial;">&forall;</span><span class="id" type="var">x</span>, <span class="id" type="var">In</span> <span class="id" type="var">x</span> <span class="id" type="var">l</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">P</span> <span class="id" type="var">x</span>) <span style="font-family: arial;">&harr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">All</span> <span class="id" type="var">P</span> <span class="id" type="var">l</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

<a name="lab183"></a><h4 class="section">Exercise: 3 stars (combine_odd_even)</h4>
 完成<span class="inlinecode"><span class="id" type="var">combine_odd_even</span></span>的定义；它取两个针对数字的性质作为它的两个参数
    <span class="inlinecode"><span class="id" type="var">Podd</span></span>和<span class="inlinecode"><span class="id" type="var">Peven</span></span>，并返回这样的性质<span class="inlinecode"><span class="id" type="var">P</span></span>：<span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span>在<span class="inlinecode"><span class="id" type="var">n</span></span>为奇数的时候等价于<span class="inlinecode"><span class="id" type="var">Podd</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span>，
    在<span class="inlinecode"><span class="id" type="var">n</span></span>为偶数的时候等价于<span class="inlinecode"><span class="id" type="var">Peven</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span>。 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">combine_odd_even</span> (<span class="id" type="var">Podd</span> <span class="id" type="var">Peven</span> : <span class="id" type="var">nat</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="keyword">Prop</span>) : <span class="id" type="var">nat</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="keyword">Prop</span><br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;REPLACE&nbsp;THIS&nbsp;LINE&nbsp;WITH&nbsp;":=&nbsp;_your_definition_&nbsp;."&nbsp;*)</span>. <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
证明下述的事实以测试你的定义是否正确。 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">combine_odd_even_intro</span> :<br/>
&nbsp;&nbsp;<span style="font-family: arial;">&forall;</span>(<span class="id" type="var">Podd</span> <span class="id" type="var">Peven</span> : <span class="id" type="var">nat</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="keyword">Prop</span>) (<span class="id" type="var">n</span> : <span class="id" type="var">nat</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">oddb</span> <span class="id" type="var">n</span> = <span class="id" type="var">true</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">Podd</span> <span class="id" type="var">n</span>) <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">oddb</span> <span class="id" type="var">n</span> = <span class="id" type="var">false</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">Peven</span> <span class="id" type="var">n</span>) <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">combine_odd_even</span> <span class="id" type="var">Podd</span> <span class="id" type="var">Peven</span> <span class="id" type="var">n</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">combine_odd_even_elim_odd</span> :<br/>
&nbsp;&nbsp;<span style="font-family: arial;">&forall;</span>(<span class="id" type="var">Podd</span> <span class="id" type="var">Peven</span> : <span class="id" type="var">nat</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="keyword">Prop</span>) (<span class="id" type="var">n</span> : <span class="id" type="var">nat</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">combine_odd_even</span> <span class="id" type="var">Podd</span> <span class="id" type="var">Peven</span> <span class="id" type="var">n</span> <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">oddb</span> <span class="id" type="var">n</span> = <span class="id" type="var">true</span> <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">Podd</span> <span class="id" type="var">n</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">combine_odd_even_elim_even</span> :<br/>
&nbsp;&nbsp;<span style="font-family: arial;">&forall;</span>(<span class="id" type="var">Podd</span> <span class="id" type="var">Peven</span> : <span class="id" type="var">nat</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="keyword">Prop</span>) (<span class="id" type="var">n</span> : <span class="id" type="var">nat</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">combine_odd_even</span> <span class="id" type="var">Podd</span> <span class="id" type="var">Peven</span> <span class="id" type="var">n</span> <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">oddb</span> <span class="id" type="var">n</span> = <span class="id" type="var">false</span> <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">Peven</span> <span class="id" type="var">n</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<span class="proofbox">&#9744;</span> 

<div class="doc">
<a name="lab184"></a><h1 class="section">Applying Theorems to Arguments</h1>

<div class="paragraph"> </div>


<div class="paragraph"> </div>

    Coq拥有一个将它从其他证明助理区分开来的特性：它将 <i>'证明本身'</i> 也作为
    第一等的值。在这一点的背后有许多更深入的细节，但是对于使用Coq而言这
    些细节并不是必须要了解的事实。这一节只是对相关内容进行一点简单的说明；
    更多的细节可以在<span class="inlinecode"><span class="id" type="var">ProofObjects</span></span>和<span class="inlinecode"><span class="id" type="var">IndPrinciples</span></span>这两个可选的章节中得知。 
<div class="paragraph"> </div>

 我们已经知道<span class="inlinecode"><span class="id" type="keyword">Check</span></span>可以显示一个表达式的类型；我们也可以用<span class="inlinecode"><span class="id" type="keyword">Check</span></span>查找某个
    名字所指的定理：
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Check</span> <span class="id" type="var">plus_comm</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;forall&nbsp;n&nbsp;m&nbsp;:&nbsp;nat,&nbsp;n&nbsp;+&nbsp;m&nbsp;=&nbsp;m&nbsp;+&nbsp;n&nbsp;*)</span><br/>
</div>

<div class="doc">
在显示<span class="inlinecode"><span class="id" type="var">plus_comm</span></span>这一定理所声明的 <i>'命题'</i> 时，Coq使用了与显示某个值的 <i>'类
    型'</i> 一样的方式。为什么会这样呢？
    实际上<span class="inlinecode"><span class="id" type="var">plus_comm</span></span>所指向的是一个被称作 <i>'证明对象'</i> 的结构，它表示了证实
    <span class="inlinecode"><span style="font-family: arial;">&forall;</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode"><span class="id" type="var">m</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">nat</span>,</span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" type="var">m</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">m</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" type="var">n</span></span>这一命题的逻辑上的演化过程。这一对象的
    类型 <i>'就是'</i> 它所证明的命题。 
<div class="paragraph"> </div>


<div class="paragraph"> </div>

    就直觉上而言这是十分自然的：定理的声明部分说明了这一定理能被用于什么场合，
    就像某个计算对象的类型说明了这一对象能被如何使用一样。例如，如果某个项的类
    型为<span class="inlinecode"><span class="id" type="var">nat</span></span> <span class="inlinecode"><span style="font-family: arial;">&rarr;</span></span> <span class="inlinecode"><span class="id" type="var">nat</span></span> <span class="inlinecode"><span style="font-family: arial;">&rarr;</span></span> <span class="inlinecode"><span class="id" type="var">nat</span></span>；这说明我们可以将其用在两个<span class="inlinecode"><span class="id" type="var">nat</span></span>上，然后得到一个<span class="inlinecode"><span class="id" type="var">nat</span></span>。
    类似地，如果我们有类型为<span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">m</span></span> <span class="inlinecode"><span style="font-family: arial;">&rarr;</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">m</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" type="var">m</span></span>的对象，当我们给出类型为<span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">m</span></span>
    的“证据”时，我们就能运用这一定理并得到<span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">m</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" type="var">m</span></span>。 
<div class="paragraph"> </div>


<div class="paragraph"> </div>

    就操作本身而言，我们能够将这种类比向前更推进一步：定理能被当作函数应用在有着正确类型的
    假设上；这样我们在将其结论特殊化的时候就不需要向证明中插入断言。比如说，假设现在我们
    想要证明如下的结果：
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">plus_comm3</span> :<br/>
&nbsp;&nbsp;<span style="font-family: arial;">&forall;</span><span class="id" type="var">n</span> <span class="id" type="var">m</span> <span class="id" type="var">p</span>, <span class="id" type="var">n</span> + (<span class="id" type="var">m</span> + <span class="id" type="var">p</span>) = (<span class="id" type="var">p</span> + <span class="id" type="var">m</span>) + <span class="id" type="var">n</span>.<br/>
</div>

<div class="doc">
这个定理的证明初看上去十分简单，我们只要用<span class="inlinecode"><span class="id" type="var">plus_comm</span></span>做两次重写就行了；然而问题是，
    第二次重写的效果会与第一次重写互相抵消：
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span> <span class="id" type="var">p</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> <span class="id" type="var">plus_comm</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> <span class="id" type="var">plus_comm</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;We&nbsp;are&nbsp;back&nbsp;where&nbsp;we&nbsp;started...&nbsp;*)</span><br/>
<span class="id" type="keyword">Abort</span>.<br/>
</div>

<div class="doc">
我们可以使用我们已经知道的工具通过这个简单的方法来解决这个问题：用<span class="inlinecode"><span class="id" type="tactic">assert</span></span>在中间插入被
    实例化了的<span class="inlinecode"><span class="id" type="var">plus_comm</span></span>；这样我们就能够按照我们想要的方式进行重写： 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">plus_comm3_take2</span> :<br/>
&nbsp;&nbsp;<span style="font-family: arial;">&forall;</span><span class="id" type="var">n</span> <span class="id" type="var">m</span> <span class="id" type="var">p</span>, <span class="id" type="var">n</span> + (<span class="id" type="var">m</span> + <span class="id" type="var">p</span>) = (<span class="id" type="var">p</span> + <span class="id" type="var">m</span>) + <span class="id" type="var">n</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span> <span class="id" type="var">p</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> <span class="id" type="var">plus_comm</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">assert</span> (<span class="id" type="var">H</span> : <span class="id" type="var">m</span> + <span class="id" type="var">p</span> = <span class="id" type="var">p</span> + <span class="id" type="var">m</span>).<br/>
&nbsp;&nbsp;{ <span class="id" type="tactic">rewrite</span> <span class="id" type="var">plus_comm</span>. <span class="id" type="tactic">reflexivity</span>. }<br/>
&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> <span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
    另外一个更为简洁优雅的方法是将<span class="inlinecode"><span class="id" type="var">plus_comm</span></span>直接应用在我们想要以之实例化的参数上，
    就像我们将一个多态函数应用到某个类型时所做的那样： 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">plus_comm3_take3</span> :<br/>
&nbsp;&nbsp;<span style="font-family: arial;">&forall;</span><span class="id" type="var">n</span> <span class="id" type="var">m</span> <span class="id" type="var">p</span>, <span class="id" type="var">n</span> + (<span class="id" type="var">m</span> + <span class="id" type="var">p</span>) = (<span class="id" type="var">p</span> + <span class="id" type="var">m</span>) + <span class="id" type="var">n</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span> <span class="id" type="var">p</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> <span class="id" type="var">plus_comm</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> (<span class="id" type="var">plus_comm</span> <span class="id" type="var">m</span>).<br/>
&nbsp;&nbsp;<span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
对于几乎所有以定理作为其参数的证明策略，你都可以这么将一个定理作为函数应用到
    某些参数上，并将得到的实例化的定理传给这些证明策略；注意，定理应用所使用的类
    型推导机制跟函数应用的是同一种，所以就像对某个函数所做的那样，你可以将通配符
    作为定理的参数，也可以将某些作为参数的前提定义为隐式参数。这些用法在以下的证
    明中都能够看到：
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">lemma_application_ex</span> :<br/>
&nbsp;&nbsp;<span style="font-family: arial;">&forall;</span>{<span class="id" type="var">n</span> : <span class="id" type="var">nat</span>} {<span class="id" type="var">ns</span> : <span class="id" type="var">list</span> <span class="id" type="var">nat</span>},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">In</span> <span class="id" type="var">n</span> (<span class="id" type="var">map</span> (<span class="id" type="keyword">fun</span> <span class="id" type="var">m</span> ⇒ <span class="id" type="var">m</span> * 0) <span class="id" type="var">ns</span>) <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">n</span> = 0.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">ns</span> <span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">destruct</span> (<span class="id" type="var">proj1</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> (<span class="id" type="var">In_map_iff</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span>) <span class="id" type="var">H</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">as</span> [<span class="id" type="var">m</span> [<span class="id" type="var">Hm</span> <span class="id" type="var">_</span>]].<br/>
&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> <span class="id" type="var">mult_0_r</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Hm</span>. <span class="id" type="tactic">rewrite</span> <span style="font-family: arial;">&larr;</span> <span class="id" type="var">Hm</span>. <span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
在以后的章节中我们将会看到更多这方面的例子。
</div>

<div class="doc">
<a name="lab185"></a><h1 class="section">Coq vs. 集合论</h1>

<div class="paragraph"> </div>


<div class="paragraph"> </div>

    Coq的核心，即被称作 <i>Calculus of Inductive Constructions</i> 的系统，在一些很重要的方面
    与其他被数学家们用于写下精确而严谨的证明的形式系统不一样。例如在主流数学中使用最普遍
    的策梅洛-弗兰克尔（Zermelo-Fraenkel）集合论：在这一形式系统中一个数学对象可以同时是许
    多不同的集合的成员；而在Coq的逻辑中，一个项有且仅有一个类型。这些区别的存在使得人们
    需要用稍微有些不同的方式去描述同一种非形式化的数学概念，但是这些都是十分自然且易于理
    解使用的。比如说，在Coq中我们一般不会说某个自然数<span class="inlinecode"><span class="id" type="var">n</span></span>属于某个包含了全体偶数的集合；而
    作为替代地, 我们会有（或定义）<span class="inlinecode"><span class="id" type="var">ev</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">nat</span></span> <span class="inlinecode"><span style="font-family: arial;">&rarr;</span></span> <span class="inlinecode"><span class="id" type="keyword">Prop</span></span>这种描述了全体偶数的性质，然后说<span class="inlinecode"><span class="id" type="var">ev</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span>
    这一命题为真。
    然而也存在着对于某些数学概念/论证而言不为核心的逻辑系统引入新的公理就难以进行
    描述甚至是无法描述的的情况。我们将以对两个世界之间的一些最显著的差别的讨论作为
    这一章节的结束。 
<div class="paragraph"> </div>

<a name="lab186"></a><h2 class="section">函数外延性</h2>

<div class="paragraph"> </div>


<div class="paragraph"> </div>

    目前为止我们所看见的有关相等性的断言基本上都只是有关归纳类型（例如<span class="inlinecode"><span class="id" type="var">nat</span></span>和
    <span class="inlinecode"><span class="id" type="var">bool</span></span>，诸如此类），但是由于Coq的相等操作符是多态的，这些并不是唯一能够有
    相等性命题的类型——举例而言，我们能够写出声明了 <i>'两个函数相等'</i> 的命题：
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">function_equality_ex<sub>1</sub></span> : <span class="id" type="var">plus</span> 3 = <span class="id" type="var">plus</span> (<span class="id" type="var">pred</span> 4).<br/>
<div class="togglescript" id="proofcontrol1" onclick="toggleDisplay('proof1');toggleDisplay('proofcontrol1')"><span class="show"></span></div>
<div class="proofscript" id="proof1" onclick="toggleDisplay('proof1');toggleDisplay('proofcontrol1')">
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>
</div>

<br/>
</div>

<div class="doc">
在一般的数学研究中，对于任意的两个函数<span class="inlinecode"><span class="id" type="var">f</span></span>和<span class="inlinecode"><span class="id" type="var">g</span></span>，只要它们所产生的结果相等，
    那么它们就会被认为相等：

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;&nbsp;&nbsp;(<span style="font-family: arial;">&forall;</span><span class="id" type="var">x</span>,&nbsp;<span class="id" type="var">f</span>&nbsp;<span class="id" type="var">x</span>&nbsp;=&nbsp;<span class="id" type="var">g</span>&nbsp;<span class="id" type="var">x</span>)&nbsp;<span style="font-family: arial;">&rarr;</span>&nbsp;<span class="id" type="var">f</span>&nbsp;=&nbsp;<span class="id" type="var">g</span>
<div class="paragraph"> </div>

</div>
    这被称作 <i>'函数外延性'</i> 原理。
    不甚严谨地说，所谓“外延性”指的是某个对象的可观察的行为；因此函数外延性指
    的就是某个函数的身份完全由其行为，（用Coq的术语来说）也就是由我们将其应用于
    参数上之后所能得到的结果确定。
    函数外延性并不在Coq的基本公理之内；因此某些“应该为真”的命题是不能被证明的：
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">function_equality_ex<sub>2</sub></span> :<br/>
&nbsp;&nbsp;(<span class="id" type="keyword">fun</span> <span class="id" type="var">x</span> ⇒ <span class="id" type="var">plus</span> <span class="id" type="var">x</span> 1) = (<span class="id" type="keyword">fun</span> <span class="id" type="var">x</span> ⇒ <span class="id" type="var">plus</span> 1 <span class="id" type="var">x</span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;卡住了&nbsp;*)</span><br/>
<span class="id" type="keyword">Abort</span>.<br/>
</div>

<div class="doc">
但是我们能用<span class="inlinecode"><span class="id" type="keyword">Axiom</span></span>这一命令将函数外延性添加到Coq的核心逻辑系统之中： 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Axiom</span> <span class="id" type="var">functional_extensionality</span> : <span style="font-family: arial;">&forall;</span>{<span class="id" type="var">X</span> <span class="id" type="var">Y</span>: <span class="id" type="keyword">Type</span>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" type="var">f</span> <span class="id" type="var">g</span> : <span class="id" type="var">X</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">Y</span>},<br/>
&nbsp;&nbsp;(<span style="font-family: arial;">&forall;</span>(<span class="id" type="var">x</span>:<span class="id" type="var">X</span>), <span class="id" type="var">f</span> <span class="id" type="var">x</span> = <span class="id" type="var">g</span> <span class="id" type="var">x</span>) <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">f</span> = <span class="id" type="var">g</span>.<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" type="keyword">Axiom</span></span>的效果与定义一个定理然后用<span class="inlinecode"><span class="id" type="var">Admitted</span></span>跳过证明部分相同，但是它会提示我们
    这是一个公理：我们不需要为其加上证明。
    现在我们能够在证明中使用函数外延性了： 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">function_equality_ex<sub>2</sub></span> :<br/>
&nbsp;&nbsp;(<span class="id" type="keyword">fun</span> <span class="id" type="var">x</span> ⇒ <span class="id" type="var">plus</span> <span class="id" type="var">x</span> 1) = (<span class="id" type="keyword">fun</span> <span class="id" type="var">x</span> ⇒ <span class="id" type="var">plus</span> 1 <span class="id" type="var">x</span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <span class="id" type="var">functional_extensionality</span>. <span class="id" type="tactic">intros</span> <span class="id" type="var">x</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <span class="id" type="var">plus_comm</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
当然，在为Coq增添新的公理的时候我们必须十分小心，因为新增添的公理可能会与
    现有的公理导致整体的 <i>'不一致'</i> ；而当系统不一致的时候，任何命题都能够被证明为真，
    包括<span class="inlinecode"><span class="id" type="var">False</span></span>。但不幸的是，并没有什么简单的能够判断某条公理会不会与现有的公理
    产生不一致的方法：一般而言，确认某一组公理的一致性都需要付出艰辛的努力；然
    而我们已经知道，添加函数外延性并不会导致这种不一致。
    我们可以用<span class="inlinecode"><span class="id" type="keyword">Print</span></span> <span class="inlinecode"><span class="id" type="var">Assumptions</span></span>查看某个证明所依赖的所有附加公理。 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Print</span> <span class="id" type="var">Assumptions</span> <span class="id" type="var">function_equality_ex<sub>2</sub></span>.<br/>
<span class="comment">(*&nbsp;===&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Axioms:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;functional_extensionality&nbsp;:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;(X&nbsp;Y&nbsp;:&nbsp;Type)&nbsp;(f&nbsp;g&nbsp;:&nbsp;X&nbsp;-&gt;&nbsp;Y),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(forall&nbsp;x&nbsp;:&nbsp;X,&nbsp;f&nbsp;x&nbsp;=&nbsp;g&nbsp;x)&nbsp;-&gt;&nbsp;f&nbsp;=&nbsp;g&nbsp;*)</span><br/>
</div>

<div class="doc">
<a name="lab187"></a><h4 class="section">Exercise: 4 stars (tr_rev)</h4>
 对于<span class="inlinecode"><span class="id" type="var">rev</span></span>的定义我们有一个问题：在<span class="inlinecode"><span class="id" type="var">rev</span></span>的每一步都会执行一次对<span class="inlinecode"><span class="id" type="var">app</span></span>的调用，
    而一次<span class="inlinecode"><span class="id" type="var">app</span></span>调用所需要的时间大致上与列表的长度成正比。也就是说，<span class="inlinecode"><span class="id" type="var">rev</span></span>有着
    与列表长度成平方关系的时间复杂度。我们能够用下面的定义来对这个问题作出改进： 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Fixpoint</span> <span class="id" type="var">rev_append</span> {<span class="id" type="var">X</span>} (<span class="id" type="var">l<sub>1</sub></span> <span class="id" type="var">l<sub>2</sub></span> : <span class="id" type="var">list</span> <span class="id" type="var">X</span>) : <span class="id" type="var">list</span> <span class="id" type="var">X</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">l<sub>1</sub></span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| [] ⇒ <span class="id" type="var">l<sub>2</sub></span><br/>
&nbsp;&nbsp;| <span class="id" type="var">x</span> :: <span class="id" type="var">l<sub>1</sub>'</span> ⇒ <span class="id" type="var">rev_append</span> <span class="id" type="var">l<sub>1</sub>'</span> (<span class="id" type="var">x</span> :: <span class="id" type="var">l<sub>2</sub></span>)<br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">tr_rev</span> {<span class="id" type="var">X</span>} (<span class="id" type="var">l</span> : <span class="id" type="var">list</span> <span class="id" type="var">X</span>) : <span class="id" type="var">list</span> <span class="id" type="var">X</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="var">rev_append</span> <span class="id" type="var">l</span> [].<br/>
</div>

<div class="doc">
这个定义被称作是 <i>'尾递归的'</i> ，因为对函数自身的递归调用是所需进行的操作中的
    最后一个（也就是说在递归调用之后我们并不进行<span class="inlinecode">++</span>）。一个足够好的编译器会针对
    这样的源码生成非常高效的目标代码。证明这两个定义等价。 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">tr_rev_correct</span> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">X</span>, @<span class="id" type="var">tr_rev</span> <span class="id" type="var">X</span> = @<span class="id" type="var">rev</span> <span class="id" type="var">X</span>.<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

<a name="lab188"></a><h2 class="section">命题与布尔代数</h2>

<div class="paragraph"> </div>

 我们已经知道在Coq中有两种不同的描述逻辑事实的方式：布尔表达式（类型为<span class="inlinecode"><span class="id" type="var">bool</span></span>的值）
    和命题（类型为<span class="inlinecode"><span class="id" type="keyword">Prop</span></span>的值）。举例而言，我们能够通过以下两种方式声明某个数字<span class="inlinecode"><span class="id" type="var">n</span></span>为偶数：

<div class="paragraph"> </div>

<ul class="doclist">
<li> (1) <span class="inlinecode"><span class="id" type="var">evenb</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span>返回<span class="inlinecode"><span class="id" type="var">true</span></span>；

</li>
<li> (2) 或者存在某些使得<span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">double</span></span> <span class="inlinecode"><span class="id" type="var">k</span></span>的数字<span class="inlinecode"><span class="id" type="var">k</span></span>。

</li>
</ul>
      这两个对“偶数性”的定义确实是等价的；我们能够证明一些辅助用的引理来证明这一点。
    我们一般说<span class="inlinecode"><span class="id" type="var">evenb</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span>这一布尔值 <i>'反映'</i> 了命题<span class="inlinecode"><span style="font-family: arial;">&exist;</span></span> <span class="inlinecode"><span class="id" type="var">k</span>,</span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">double</span></span> <span class="inlinecode"><span class="id" type="var">k</span></span>。 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">evenb_double</span> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">k</span>, <span class="id" type="var">evenb</span> (<span class="id" type="var">double</span> <span class="id" type="var">k</span>) = <span class="id" type="var">true</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">k</span>. <span class="id" type="tactic">induction</span> <span class="id" type="var">k</span> <span class="id" type="keyword">as</span> [|<span class="id" type="var">k'</span> <span class="id" type="var">IHk'</span>].<br/>
&nbsp;&nbsp;- <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">IHk'</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a name="lab189"></a><h4 class="section">Exercise: 3 stars (evenb_double_conv)</h4>

</div>
<div class="code code-space">
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">evenb_double_conv</span> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">n</span>,<br/>
&nbsp;&nbsp;<span style="font-family: arial;">&exist;</span><span class="id" type="var">k</span>, <span class="id" type="var">n</span> = <span class="id" type="keyword">if</span> <span class="id" type="var">evenb</span> <span class="id" type="var">n</span> <span class="id" type="keyword">then</span> <span class="id" type="var">double</span> <span class="id" type="var">k</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">else</span> <span class="id" type="var">S</span> (<span class="id" type="var">double</span> <span class="id" type="var">k</span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;Hint:&nbsp;Use&nbsp;the&nbsp;<span class="inlinecode"><span class="id" type="var">evenb_S</span></span>&nbsp;lemma&nbsp;from&nbsp;<span class="inlinecode"><span class="id" type="var">Induction.v</span></span>.&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">even_bool_prop</span> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">n</span>,<br/>
&nbsp;&nbsp;<span class="id" type="var">evenb</span> <span class="id" type="var">n</span> = <span class="id" type="var">true</span> <span style="font-family: arial;">&harr;</span> <span style="font-family: arial;">&exist;</span><span class="id" type="var">k</span>, <span class="id" type="var">n</span> = <span class="id" type="var">double</span> <span class="id" type="var">k</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span>. <span class="id" type="tactic">split</span>.<br/>
&nbsp;&nbsp;- <span class="id" type="tactic">intros</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">destruct</span> (<span class="id" type="var">evenb_double_conv</span> <span class="id" type="var">n</span>) <span class="id" type="keyword">as</span> [<span class="id" type="var">k</span> <span class="id" type="var">Hk</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> <span class="id" type="var">Hk</span>. <span class="id" type="tactic">rewrite</span> <span class="id" type="var">H</span>. <span style="font-family: arial;">&exist;</span><span class="id" type="var">k</span>. <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="id" type="tactic">intros</span> [<span class="id" type="var">k</span> <span class="id" type="var">Hk</span>]. <span class="id" type="tactic">rewrite</span> <span class="id" type="var">Hk</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">evenb_double</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
类似地，我们可以用类似的两种方式声明任意的两个数字<span class="inlinecode"><span class="id" type="var">n</span></span>和<span class="inlinecode"><span class="id" type="var">m</span></span>的相等性：(1)
    <span class="inlinecode"><span class="id" type="var">beq_nat</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode"><span class="id" type="var">m</span></span>返回<span class="inlinecode"><span class="id" type="var">true</span></span>，以及(2)<span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">m</span></span>。这两种方式也是等价的。 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">beq_nat_true_iff</span> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">n<sub>1</sub></span> <span class="id" type="var">n<sub>2</sub></span> : <span class="id" type="var">nat</span>,<br/>
&nbsp;&nbsp;<span class="id" type="var">beq_nat</span> <span class="id" type="var">n<sub>1</sub></span> <span class="id" type="var">n<sub>2</sub></span> = <span class="id" type="var">true</span> <span style="font-family: arial;">&harr;</span> <span class="id" type="var">n<sub>1</sub></span> = <span class="id" type="var">n<sub>2</sub></span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n<sub>1</sub></span> <span class="id" type="var">n<sub>2</sub></span>. <span class="id" type="tactic">split</span>.<br/>
&nbsp;&nbsp;- <span class="id" type="tactic">apply</span> <span class="id" type="var">beq_nat_true</span>.<br/>
&nbsp;&nbsp;- <span class="id" type="tactic">intros</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">rewrite</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">rewrite</span> <span style="font-family: arial;">&larr;</span> <span class="id" type="var">beq_nat_refl</span>. <span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
然而，即使就逻辑上而言这两种表达方式是等价的，在进行具体的操作时它们也是不一样的。
    相等性就是这种例子之中较为极端的一个：<span class="inlinecode"><span class="id" type="var">beq_nat</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode"><span class="id" type="var">m</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">true</span></span>这一假设对于有关<span class="inlinecode"><span class="id" type="var">n</span></span>和<span class="inlinecode"><span class="id" type="var">m</span></span>的
    命题的证明而言几乎没有帮助，但是如果我们将这一假设变换为<span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">m</span></span>这一等价的形式，我们就
    能够将其用于重写。
    偶数性也是一个比较有意思的例子。回想一下，在我们证明<span class="inlinecode"><span class="id" type="var">even_bool_prop</span></span>的反方向部分
    （即<span class="inlinecode"><span class="id" type="var">evenb_double</span></span>，从命题到布尔表达式的方向）的时候，我们只是简单地对<span class="inlinecode"><span class="id" type="var">k</span></span>使用了
    归纳法；而证明另一个方向（即<span class="inlinecode"><span class="id" type="var">evenb_double_conv</span></span>这一练习）的命题则需要某种十分聪明
    的对命题进行一般化的手段，因为我们不能直接证明<span class="inlinecode">(<span style="font-family: arial;">&exist;</span></span> <span class="inlinecode"><span class="id" type="var">k</span>,</span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">double</span></span> <span class="inlinecode"><span class="id" type="var">k</span>)</span> <span class="inlinecode"><span style="font-family: arial;">&rarr;</span></span> <span class="inlinecode"><span class="id" type="var">evenb</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">true</span></span>。
    对这些例子而言，命题性的声明比起它们所对应的布尔表达式而言要更为有用；但并不是
    在任何情况下都是如此。比如说，在函数的定义里我们不能检查某个任意的命题是否为真；
    因此这段代码是不被接受的： 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="var">Fail</span> <span class="id" type="keyword">Definition</span> <span class="id" type="var">is_even_prime</span> <span class="id" type="var">n</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">if</span> <span class="id" type="var">n</span> = 2 <span class="id" type="keyword">then</span> <span class="id" type="var">true</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">else</span> <span class="id" type="var">false</span>.<br/>
</div>

<div class="doc">
    Coq会拒绝接受这段代码并给出「<span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode">2</span>的类型为<span class="inlinecode"><span class="id" type="keyword">Prop</span></span>」这样的错误信息，因为它想要的
    是一个<span class="inlinecode"><span class="id" type="var">bool</span></span>（或其他的有两个元素的归纳类型）。出现这条错误信息的原因跟Coq的核心语言
    有关：其 <i>'计算性'</i> 的特性使得它只能表达可计算的全函数。这么做的原因之一是为了能够
    从使用Coq开发的代码中抽取可以执行的程序。因此在Coq中 <i>'并没有'</i> 某种通用的判断任意
    <span class="inlinecode"><span class="id" type="keyword">Prop</span></span>是否为真的按类分析操作：一旦存在这种操作，我们就能够用它来写出不可计算的函数。

<div class="paragraph"> </div>

    即使一般的不可计算的函数不能被表示为布尔代数中的运算，我们也应该知道即使是对于 <i>'可计算的'</i> 
    性质而言也存在着使用<span class="inlinecode"><span class="id" type="keyword">Prop</span></span>会比<span class="inlinecode"><span class="id" type="var">bool</span></span>方便的场合，因为递归函数定义受限于Coq对于相关内容的限制。
    比如说，下一章将会讲述如何使用<span class="inlinecode"><span class="id" type="keyword">Prop</span></span>定义「某个正则表达式可以匹配某个给出的字符串」这一性质；
    如果使用<span class="inlinecode"><span class="id" type="var">bool</span></span>，那么就会需要真的写一个正则表达式的匹配器：这么做会更加复杂，更加难以理解，同时
    也更加难以对相关的内容进行推理和证明。
    相反的，使用布尔值会带来一个重要的好处：通过对Coq中的项进行计算能够实现一些证明的自动化。这一
    技巧被称作<i>proof by reflection_。考虑下面的例子： 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">even_1000</span> : <span style="font-family: arial;">&exist;</span><span class="id" type="var">k</span>, 1000 = <span class="id" type="var">double</span> <span class="id" type="var">k</span>.<br/>
</div>

<div class="doc">
对于这个命题而言，最为直接的证明方式是直接给出<span class="inlinecode"><span class="id" type="var">k</span></span>的值。 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Proof</span>. <span style="font-family: arial;">&exist;</span>500. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
而与它对应的使用了布尔值的声明的证明则要更加简单些： 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">even_1000'</span> : <span class="id" type="var">evenb</span> 1000 = <span class="id" type="var">true</span>.<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
有趣的是，因为这两种定义是等价的，我们能够不显式地指出500这个值而用相对应的布尔值
    方程式去完成它的对应物的证明： 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">even_1000''</span> : <span style="font-family: arial;">&exist;</span><span class="id" type="var">k</span>, 1000 = <span class="id" type="var">double</span> <span class="id" type="var">k</span>.<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">even_bool_prop</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
    虽然在这个例子中证明的长度并没有因此而缩减多少，但是对于更加大型的证明我们一般都
    可以用反射技巧让它们变得更小。一个比较极端的例子是，在用Coq证明著名的 <i>'四色定理'</i> 
    时人们使用了反射技巧将对几百种不同的情况的分析工作缩减成一个对布尔值的计算。我们
    不会详细地讲解反射技巧，但是对于展示布尔值计算和一般命题的互补的优势而言，它是个
    很好的例子。 
<div class="paragraph"> </div>

<a name="lab190"></a><h4 class="section">Exercise: 2 stars (logical_connectives)</h4>
 下述引理将在这一章中进行了讨论的命题性的连接符跟相对应的布尔运算操作联系了起来。
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">andb_true_iff</span> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">b<sub>1</sub></span> <span class="id" type="var">b<sub>2</sub></span>:<span class="id" type="var">bool</span>,<br/>
&nbsp;&nbsp;<span class="id" type="var">b<sub>1</sub></span> &amp;&amp; <span class="id" type="var">b<sub>2</sub></span> = <span class="id" type="var">true</span> <span style="font-family: arial;">&harr;</span> <span class="id" type="var">b<sub>1</sub></span> = <span class="id" type="var">true</span> <span style="font-family: arial;">&and;</span> <span class="id" type="var">b<sub>2</sub></span> = <span class="id" type="var">true</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">orb_true_iff</span> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">b<sub>1</sub></span> <span class="id" type="var">b<sub>2</sub></span>,<br/>
&nbsp;&nbsp;<span class="id" type="var">b<sub>1</sub></span> || <span class="id" type="var">b<sub>2</sub></span> = <span class="id" type="var">true</span> <span style="font-family: arial;">&harr;</span> <span class="id" type="var">b<sub>1</sub></span> = <span class="id" type="var">true</span> <span style="font-family: arial;">&or;</span> <span class="id" type="var">b<sub>2</sub></span> = <span class="id" type="var">true</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

<a name="lab191"></a><h4 class="section">Exercise: 1 star (beq_nat_false_iff)</h4>
 下述引理是命题<span class="inlinecode"><span class="id" type="var">beq_nat_true_iff</span></span>的“非”版本；在某些情况下这一引理会使事情变得
    更为方便些。（在以后的章节中我们将会看到更多这方面的例子） 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">beq_nat_false_iff</span> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">x</span> <span class="id" type="var">y</span> : <span class="id" type="var">nat</span>,<br/>
&nbsp;&nbsp;<span class="id" type="var">beq_nat</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span> = <span class="id" type="var">false</span> <span style="font-family: arial;">&harr;</span> <span class="id" type="var">x</span> ≠ <span class="id" type="var">y</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

<a name="lab192"></a><h4 class="section">Exercise: 3 stars (beq_list)</h4>
 给定一个用于确定类型为<span class="inlinecode"><span class="id" type="var">A</span></span>的值之间的相等性的布尔操作符<span class="inlinecode"><span class="id" type="var">beq</span></span>，我们能够定义
    可以检测两个包含类型为<span class="inlinecode"><span class="id" type="var">A</span></span>的值的列表是否相等的函数<span class="inlinecode"><span class="id" type="var">beq_list</span></span> <span class="inlinecode"><span class="id" type="var">beq</span></span>。完成下面
    <span class="inlinecode"><span class="id" type="var">beq_list</span></span>的定义。证明<span class="inlinecode"><span class="id" type="var">beq_list_true_iff</span></span>这一引理以确认你的定义是正确的。 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Fixpoint</span> <span class="id" type="var">beq_list</span> {<span class="id" type="var">A</span> : <span class="id" type="keyword">Type</span>} (<span class="id" type="var">beq</span> : <span class="id" type="var">A</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">A</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">bool</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">l<sub>1</sub></span> <span class="id" type="var">l<sub>2</sub></span> : <span class="id" type="var">list</span> <span class="id" type="var">A</span>) : <span class="id" type="var">bool</span><br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;REPLACE&nbsp;THIS&nbsp;LINE&nbsp;WITH&nbsp;":=&nbsp;_your_definition_&nbsp;."&nbsp;*)</span>. <span class="id" type="var">Admitted</span>.<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">beq_list_true_iff</span> :<br/>
&nbsp;&nbsp;<span style="font-family: arial;">&forall;</span><span class="id" type="var">A</span> (<span class="id" type="var">beq</span> : <span class="id" type="var">A</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">A</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">bool</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span style="font-family: arial;">&forall;</span><span class="id" type="var">a<sub>1</sub></span> <span class="id" type="var">a<sub>2</sub></span>, <span class="id" type="var">beq</span> <span class="id" type="var">a<sub>1</sub></span> <span class="id" type="var">a<sub>2</sub></span> = <span class="id" type="var">true</span> <span style="font-family: arial;">&harr;</span> <span class="id" type="var">a<sub>1</sub></span> = <span class="id" type="var">a<sub>2</sub></span>) <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-family: arial;">&forall;</span><span class="id" type="var">l<sub>1</sub></span> <span class="id" type="var">l<sub>2</sub></span>, <span class="id" type="var">beq_list</span> <span class="id" type="var">beq</span> <span class="id" type="var">l<sub>1</sub></span> <span class="id" type="var">l<sub>2</sub></span> = <span class="id" type="var">true</span> <span style="font-family: arial;">&harr;</span> <span class="id" type="var">l<sub>1</sub></span> = <span class="id" type="var">l<sub>2</sub></span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

<a name="lab193"></a><h4 class="section">Exercise: 2 stars, recommended (All_forallb)</h4>
 回忆一下在<a href="Tactics.html"><span class="inlineref">Tactics</span></a>一章中来自练习<span class="inlinecode"><span class="id" type="var">forall_exists_challenge</span></span>的函数<span class="inlinecode"><span class="id" type="var">forallb</span></span>： 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Fixpoint</span> <span class="id" type="var">forallb</span> {<span class="id" type="var">X</span> : <span class="id" type="keyword">Type</span>} (<span class="id" type="var">test</span> : <span class="id" type="var">X</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">bool</span>) (<span class="id" type="var">l</span> : <span class="id" type="var">list</span> <span class="id" type="var">X</span>) : <span class="id" type="var">bool</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">l</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| [] ⇒ <span class="id" type="var">true</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">x</span> :: <span class="id" type="var">l'</span> ⇒ <span class="id" type="var">andb</span> (<span class="id" type="var">test</span> <span class="id" type="var">x</span>) (<span class="id" type="var">forallb</span> <span class="id" type="var">test</span> <span class="id" type="var">l'</span>)<br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>
</div>

<div class="doc">
证明下述将<span class="inlinecode"><span class="id" type="var">forallb</span></span>跟<span class="inlinecode"><span class="id" type="var">All</span></span>这一性质联系起来的定理。
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">forallb_true_iff</span> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">X</span> <span class="id" type="var">test</span> (<span class="id" type="var">l</span> : <span class="id" type="var">list</span> <span class="id" type="var">X</span>),<br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="var">forallb</span> <span class="id" type="var">test</span> <span class="id" type="var">l</span> = <span class="id" type="var">true</span> <span style="font-family: arial;">&harr;</span> <span class="id" type="var">All</span> (<span class="id" type="keyword">fun</span> <span class="id" type="var">x</span> ⇒ <span class="id" type="var">test</span> <span class="id" type="var">x</span> = <span class="id" type="var">true</span>) <span class="id" type="var">l</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
是否存在没有被这个规范描述包括的关于函数<span class="inlinecode"><span class="id" type="var">forallb</span></span>的性质？
</div>
<div class="code code-tight">

<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

<a name="lab194"></a><h2 class="section">经典逻辑 vs. 构造逻辑</h2>

<div class="paragraph"> </div>


<div class="paragraph"> </div>

    我们已经知道，在定义一个Coq函数时我们没有办法判断某个命题<span class="inlinecode"><span class="id" type="var">P</span></span>是否为真；你或许会
    对为此感到惊讶：对于 <i>'证明'</i> 而言也存在类似的限制！换句话说，下面的推理原则即使
    符合直觉，但是在Coq中它是不可被证明的：
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">excluded_middle</span> := <span style="font-family: arial;">&forall;</span><span class="id" type="var">P</span> : <span class="id" type="keyword">Prop</span>,<br/>
&nbsp;&nbsp;<span class="id" type="var">P</span> <span style="font-family: arial;">&or;</span> ¬ <span class="id" type="var">P</span>.<br/>
</div>

<div class="doc">
    回想一下，在证明形如<span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode"><span style="font-family: arial;">&or;</span></span> <span class="inlinecode"><span class="id" type="var">Q</span></span>的命题时，我们使用<span class="inlinecode"><span class="id" type="var">left</span></span>和<span class="inlinecode"><span class="id" type="var">right</span></span>这两个策略；为了使用
    这两个策略证明这些命题，我们需要知道哪一边能够被证明为真。但是在<span class="inlinecode"><span class="id" type="var">excluded_middle</span></span>中，
    <span class="inlinecode"><span class="id" type="var">P</span></span>是被全程量化的，它可以指代任意命题；因此我们对<span class="inlinecode"><span class="id" type="var">P</span></span>本身一无所知，所以我们也不能得到
    足够让我们确定用<span class="inlinecode"><span class="id" type="var">left</span></span>还是<span class="inlinecode"><span class="id" type="var">right</span></span>的信息，就像Coq因为缺乏信息而不能在函数内部机械地确定
    <span class="inlinecode"><span class="id" type="var">P</span></span>是否为真一样。 
<div class="paragraph"> </div>

 然而，如果我们恰好知道<span class="inlinecode"><span class="id" type="var">P</span></span>被某个布尔项<span class="inlinecode"><span class="id" type="var">b</span></span>反射，那么我们就能很轻易地知道它究竟是否为真：
    我们只要检测<span class="inlinecode"><span class="id" type="var">b</span></span>的值就可以了。 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">restricted_excluded_middle</span> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">P</span> <span class="id" type="var">b</span>,<br/>
&nbsp;&nbsp;(<span class="id" type="var">P</span> <span style="font-family: arial;">&harr;</span> <span class="id" type="var">b</span> = <span class="id" type="var">true</span>) <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">P</span> <span style="font-family: arial;">&or;</span> ¬ <span class="id" type="var">P</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">P</span> [] <span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;- <span class="id" type="var">left</span>. <span class="id" type="tactic">rewrite</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="id" type="var">right</span>. <span class="id" type="tactic">rewrite</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">intros</span> <span class="id" type="var">contra</span>. <span class="id" type="tactic">inversion</span> <span class="id" type="var">contra</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
特别地，对于关于自然数<span class="inlinecode"><span class="id" type="var">n</span></span>和<span class="inlinecode"><span class="id" type="var">m</span></span>的等式<span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">m</span></span>而言，排中律是成立的。
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">restricted_excluded_middle_eq</span> : <span style="font-family: arial;">&forall;</span>(<span class="id" type="var">n</span> <span class="id" type="var">m</span> : <span class="id" type="var">nat</span>),<br/>
&nbsp;&nbsp;<span class="id" type="var">n</span> = <span class="id" type="var">m</span> <span style="font-family: arial;">&or;</span> <span class="id" type="var">n</span> ≠ <span class="id" type="var">m</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> (<span class="id" type="var">restricted_excluded_middle</span> (<span class="id" type="var">n</span> = <span class="id" type="var">m</span>) (<span class="id" type="var">beq_nat</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span>)).<br/>
&nbsp;&nbsp;<span class="id" type="tactic">symmetry</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <span class="id" type="var">beq_nat_true_iff</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
    通用的排中律在Coq中并不是默认可以使用的；这一点看上去或许很奇怪，毕竟任何声明
    肯定都是非真即假的。然而不假设排中律存在也有它的优势：Coq中的声明可以比在标准数学
    中同样的声明更强。比如说，如果存在<span class="inlinecode"><span style="font-family: arial;">&exist;</span></span> <span class="inlinecode"><span class="id" type="var">x</span>,</span> <span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode"><span class="id" type="var">x</span></span>的Coq证明，那么我们就能够直接
    展示出能够让我们证明<span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode"><span class="id" type="var">x</span></span>的<span class="inlinecode"><span class="id" type="var">x</span></span>的值；也就是说，任何关于存在性的证明一定都是 <i>'构造性'</i> 的。 
<div class="paragraph"> </div>

 像Coq一样不假设排中律的正确性的逻辑系统被称作 <i>'构造逻辑'</i> ；而更加常规的、排中律
    对于任意命题都成立的逻辑系统（例如ZFC集合论）则被称作 <i>'经典逻辑'</i> 。 
<div class="paragraph"> </div>

 下述例子展示了为什么假设排中律成立会导致非构造性的证明：
    <i>'声明'</i> ：存在无理数<span class="inlinecode"><span class="id" type="var">a</span></span>和<span class="inlinecode"><span class="id" type="var">b</span></span>使得<span class="inlinecode"><span class="id" type="var">a</span></span> <span class="inlinecode">^</span> <span class="inlinecode"><span class="id" type="var">b</span></span>为有理数。
    <i>'证明'</i> ：易知<span class="inlinecode"><span class="id" type="var">sqrt</span></span> <span class="inlinecode">2</span>为无理数。如果<span class="inlinecode"><span class="id" type="var">sqrt</span></span> <span class="inlinecode">2</span> <span class="inlinecode">^</span> <span class="inlinecode"><span class="id" type="var">sqrt</span></span> <span class="inlinecode">2</span>为有理数，那么可以取
    <span class="inlinecode"><span class="id" type="var">a</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">b</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">sqrt</span></span> <span class="inlinecode">2</span>；如果<span class="inlinecode"><span class="id" type="var">sqrt</span></span> <span class="inlinecode">2</span> <span class="inlinecode">^</span> <span class="inlinecode"><span class="id" type="var">sqrt</span></span> <span class="inlinecode">2</span>为无理数，那么可以取<span class="inlinecode"><span class="id" type="var">a</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">sqrt</span></span> <span class="inlinecode">2</span> <span class="inlinecode">^</span> <span class="inlinecode"><span class="id" type="var">sqrt</span></span> <span class="inlinecode">2</span>和
    <span class="inlinecode"><span class="id" type="var">b</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">sqrt</span></span> <span class="inlinecode">2</span>，因为<span class="inlinecode"><span class="id" type="var">a</span></span> <span class="inlinecode">^</span> <span class="inlinecode"><span class="id" type="var">b</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">sqrt</span></span> <span class="inlinecode">2</span> <span class="inlinecode">^</span> <span class="inlinecode">(<span class="id" type="var">sqrt</span></span> <span class="inlinecode">2</span> <span class="inlinecode">*</span> <span class="inlinecode"><span class="id" type="var">sqrt</span></span> <span class="inlinecode">2)</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">sqrt</span></span> <span class="inlinecode">2</span> <span class="inlinecode">^</span> <span class="inlinecode">2</span> <span class="inlinecode">=</span> <span class="inlinecode">2</span>。<span class="proofbox">&#9744;</span>
    看得到在这个证明中发生了什么吗？我们在不知道<span class="inlinecode"><span class="id" type="var">sqrt</span></span> <span class="inlinecode">2</span> <span class="inlinecode">^</span> <span class="inlinecode"><span class="id" type="var">sqrt</span></span> <span class="inlinecode">2</span>是否为有理数的
    情况下就使用了排中律将它分为两种不同的情况；因此在最后，我们知道这样的<span class="inlinecode"><span class="id" type="var">a</span></span>和<span class="inlinecode"><span class="id" type="var">b</span></span>
    是存在的，但是我们并不能确定它们的值。
    即使构造逻辑很有用，它也有它的限制：有很多在经典逻辑中能够轻易被证明的声明会有
    更加复杂的构造性证明，而对于某些声明而言这样的证明甚至不存在。幸运的是，排中律
    就像函数外延性一样与Coq的逻辑系统相兼容；我们可以安全地将其作为公理添加到Coq中。
    但是在这本书中我们不需要这样做：这本书所覆盖的内容都可以使用构造逻辑得到，而且
    因此所产生的额外的耗费都微不足道。
    一般而言在意识到有哪些证明技巧不应该在进行构建性证明时使用之前都要经过一定的实践和
    练习，但是在这些证明技巧之中反证法尤为臭名昭著，因为它的使用将会导向一个非构造性的
    证明。这里是一个典型的例子：假设我们希望证明存在有着性质<span class="inlinecode"><span class="id" type="var">P</span></span>的某个<span class="inlinecode"><span class="id" type="var">x</span></span>，也就是说，
    我们希望证明存在某个<span class="inlinecode"><span class="id" type="var">x</span></span>使得<span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode"><span class="id" type="var">x</span></span>。我们先假设这个命题为假，即假设<span class="inlinecode">¬</span> <span class="inlinecode"><span style="font-family: arial;">&exist;</span></span> <span class="inlinecode"><span class="id" type="var">x</span>,</span> <span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode"><span class="id" type="var">x</span></span>。
    从这个假设中我们不用特别费劲就能得到<span class="inlinecode"><span style="font-family: arial;">&forall;</span></span> <span class="inlinecode"><span class="id" type="var">x</span>,</span> <span class="inlinecode">¬</span> <span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode"><span class="id" type="var">x</span></span>。如果我们能够通过这个命题得到
    矛盾，我们就能够得到一个对于存在性的证明，即使我们完全没有指出能够使<span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode"><span class="id" type="var">x</span></span>成立的<span class="inlinecode"><span class="id" type="var">x</span></span>的值。
    从构造性的角度来看，在这里存在着的技术上的瑕疵，是我们试图用<span class="inlinecode">¬</span> <span class="inlinecode">¬</span> <span class="inlinecode">(<span style="font-family: arial;">&exist;</span></span> <span class="inlinecode"><span class="id" type="var">x</span>,</span> <span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode"><span class="id" type="var">x</span>)</span>的证明
    去证明<span class="inlinecode"><span style="font-family: arial;">&exist;</span></span> <span class="inlinecode"><span class="id" type="var">x</span>,</span> <span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode"><span class="id" type="var">x</span></span>。从下面的练习我们可以看到，允许自己从任意声明中去掉双重否定等价于
    引入排中律。因此只要不引入这一额外的公理，我们就不能在Coq中写出这行证明。 
<div class="paragraph"> </div>

<a name="lab195"></a><h4 class="section">Exercise: 3 stars (excluded_middle_irrefutable)</h4>
 通用的排中律跟Coq之间的一致性的证明十分复杂而且并不能在Coq系统自身进行。然而，下述定理
    说明了对于 <i>'任意指定的某个'</i> Prop <span class="inlinecode"><span class="id" type="var">P</span></span>而言，加入一个可判定公理（也就是一个排中律的特例）
    都是安全的。之所以这样是因为我们不能证明这样的公理的否定命题；如果我们能够证明这样的命题，
    那么我们就会同时有<span class="inlinecode">¬</span> <span class="inlinecode">(<span class="id" type="var">P</span></span> <span class="inlinecode"><span style="font-family: arial;">&or;</span></span> <span class="inlinecode">¬<span class="id" type="var">P</span>)</span>和<span class="inlinecode">¬</span> <span class="inlinecode">¬</span> <span class="inlinecode">(<span class="id" type="var">P</span></span> <span class="inlinecode"><span style="font-family: arial;">&or;</span></span> <span class="inlinecode">¬<span class="id" type="var">P</span>)</span>，而这将产生矛盾。
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">excluded_middle_irrefutable</span>:  <span style="font-family: arial;">&forall;</span>(<span class="id" type="var">P</span>:<span class="id" type="keyword">Prop</span>),<br/>
&nbsp;&nbsp;¬ ¬ (<span class="id" type="var">P</span> <span style="font-family: arial;">&or;</span> ¬ <span class="id" type="var">P</span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

<a name="lab196"></a><h4 class="section">Exercise: 3 stars, advanced (not_exists_dist)</h4>
 在经典逻辑中有这么一条定理；它声明下述两条假设是等价的：

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;&nbsp;&nbsp;¬&nbsp;(<span style="font-family: arial;">&exist;</span><span class="id" type="var">x</span>,&nbsp;¬&nbsp;<span class="id" type="var">P</span>&nbsp;<span class="id" type="var">x</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-family: arial;">&forall;</span><span class="id" type="var">x</span>,&nbsp;<span class="id" type="var">P</span>&nbsp;<span class="id" type="var">x</span>
<div class="paragraph"> </div>

</div>
    <span class="inlinecode"><span class="id" type="var">dist_not_exists</span></span>证明了这一等价性的其中一个方向。有趣的事是，在构造逻辑中我们
    不能证明另外一个方向。你的任务就是证明这个方向的证明能够使用排中律得到。
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">not_exists_dist</span> :<br/>
&nbsp;&nbsp;<span class="id" type="var">excluded_middle</span> <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;<span style="font-family: arial;">&forall;</span>(<span class="id" type="var">X</span>:<span class="id" type="keyword">Type</span>) (<span class="id" type="var">P</span> : <span class="id" type="var">X</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="keyword">Prop</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;¬ (<span style="font-family: arial;">&exist;</span><span class="id" type="var">x</span>, ¬ <span class="id" type="var">P</span> <span class="id" type="var">x</span>) <span style="font-family: arial;">&rarr;</span> (<span style="font-family: arial;">&forall;</span><span class="id" type="var">x</span>, <span class="id" type="var">P</span> <span class="id" type="var">x</span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

<a name="lab197"></a><h4 class="section">Exercise: 5 stars, optional (classical_axioms)</h4>
 对于那些喜欢挑战的人，这里是摘自Bertor和Casteran所著的Coq'Art这本书（第123页）的练习。
    下述的四个句子，包括上面提到的<span class="inlinecode"><span class="id" type="var">excluded_middle</span></span>，都被认为描述了经典逻辑。在Coq中我们不能
    证明它们，但是假如我们希望在经典逻辑下工作的话，我们可以安全地将其中任意一条作为公理添加
    到Coq中。
    证明这五个命题（以下四个以及<span class="inlinecode"><span class="id" type="var">excluded_middle</span></span>）互相等价。 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">peirce</span> := <span style="font-family: arial;">&forall;</span><span class="id" type="var">P</span> <span class="id" type="var">Q</span>: <span class="id" type="keyword">Prop</span>,<br/>
&nbsp;&nbsp;((<span class="id" type="var">P</span><span style="font-family: arial;">&rarr;</span><span class="id" type="var">Q</span>)<span style="font-family: arial;">&rarr;</span><span class="id" type="var">P</span>)<span style="font-family: arial;">&rarr;</span><span class="id" type="var">P</span>.<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">double_negation_elimination</span> := <span style="font-family: arial;">&forall;</span><span class="id" type="var">P</span>:<span class="id" type="keyword">Prop</span>,<br/>
&nbsp;&nbsp;~~<span class="id" type="var">P</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">P</span>.<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">de_morgan_not_and_not</span> := <span style="font-family: arial;">&forall;</span><span class="id" type="var">P</span> <span class="id" type="var">Q</span>:<span class="id" type="keyword">Prop</span>,<br/>
&nbsp;&nbsp;~(~<span class="id" type="var">P</span> <span style="font-family: arial;">&and;</span> ¬<span class="id" type="var">Q</span>) <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">P</span><span style="font-family: arial;">&or;</span><span class="id" type="var">Q</span>.<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">implies_to_or</span> := <span style="font-family: arial;">&forall;</span><span class="id" type="var">P</span> <span class="id" type="var">Q</span>:<span class="id" type="keyword">Prop</span>,<br/>
&nbsp;&nbsp;(<span class="id" type="var">P</span><span style="font-family: arial;">&rarr;</span><span class="id" type="var">Q</span>) <span style="font-family: arial;">&rarr;</span> (¬<span class="id" type="var">P</span><span style="font-family: arial;">&or;</span><span class="id" type="var">Q</span>).<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

  
</div>
</div>

<div id="footer">
<hr/><a href="coqindex.html">Index</a></div>

</div>

</body>
</html>